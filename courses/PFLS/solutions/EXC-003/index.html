<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Solution for EXC-003</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #217573;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Solution for EXC-003</p>
                        <p>You shall not pass! Well, unless you have the password. Then you pass .. or <a href="/courses/PFLS/#exc-003">go back to where you came from</a>.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="SHOW ME" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d295dc3a1f0b51cd978bcd6cd2e41bc8434de563292569489f4eda76c3fea1a9fc685a69e9b7c28232f65690151b9b6a5eb496d1f9f1e1901793ae3ae42c34926434dd8c1b99c27596f30a1c1942fd640615e1c87b292181b76db8e2e9040b723db83196b09de3ea7882e9ef2b70f6b9bb8b35428f5971f1e4f6a1fea33e0e10690aba8c145ed8b07c597f62880243ce455e04544248d631b02815aab147cfe661358936a88d4fd296e19cf4f674a0fe3b6fae7c261b7466dd97b014f40533db825791e8dc7fff23506923848a6034457908d6d40436657779343600659d4604bc276a2194518bfefb5eaf00263cb3d239d2f660f2b8d13b5278f236789a5cc24987a03c88ff4823470236d713125ff1ec818f4e27617a4803a1fb79712061ed95190589eb45b50dec4964cb140c039b6251ce3a71f142d17acd6ff72a687f3b2e29c5acde405c3368d6ef685b91ef932eb452a1b27ac18cd47ff83ddd5c267299314a91ae6225ba68bdd59edb259a27c2cedf494638c39270bfe4f3f449081f2d5aad41f6acb55b5fbe301dd43133e8084ad35c871c449d40671fffbfefc316307cdd0d795b6ab46d5a5b7aa6904221dfb2c5a71b049fa4d079fc095c968ed2b9ed48722501532af7dc21044981c366a0f0da4658af837e8de4ddae0030e60fce5bb22fb48c39cb42babca12c493e2d8dfb8077b4fdadd757fb6bdac490f907488d39038f29f6b7c6b34556b0a701361abac0c241c6d1aff0cf47276a479db24d9e0eaf0fe691cce64583779ddbfd5cb67607a0c213c0287704f177194e599866fef99caee545aab9f4d3edc7c83e12bf5018d4e6bd5ddf5bf4739c2d9ffb263c851c6c94a94cbccd87295ed0c73735e234b8af3078e69ac9dead522bea8470313270b77171417173934353d1071a034f2bf422da0ec3b22c2689a3f4fe64eb90220eb63ea84775b7eec86d7d138dd3e34633bb58420953a7cab607f2d4d08695ac750e2f4c9fc444c34016c46d7abcfd05e2ec9293c6acc298d58f641f88734e9c2c94b246d78a9cea11ed96e0f6408489a5e0131e1f69864c59239bd0db70d37798ba5e8b497b224f5a1fec5c40a34b6f4575285e9cf993c6a404cbe88e6b452d470b118f3b4baff4655ac9735085353e6bb8022da1eabc442dc163408c9e9fb4bbf226e48732cf086dc2412f69b9955593a9e70e36b8c4782e54998684633194b6d9bfe263a223dc1d1fd98458197b2178471530903a90272f0714784a658cbafad36351c5c34ac4eabccca7d2e02328d98d91d13f86a5a594df36031a37a87d829fc53ff048557c46edc7d9a4ae891431ca4b0981de6bcf6f97df782a69fcf068a7c1b14dbacc85fc15a79fa8260e296e531dbf917c580afbc6d1af024566f9e068616126a6efbed337c02361b360ffd4668c325a786bba5a8da1ad5d8a06646471d7994fefbb7c6e34a3f4c8e970c3cd91d4f41c3e71364aadcd649f6e6cffc36ffc73c3cedd77ff7b7466e7e7b8175afa6183b2575c20a71a72b260932821918b9b00f49756b0b9f29c9210695b031e2792a9655a4b8e20433c18ce81fa44511d67fb1680efda9e45830e34309c17ae6755d7ce82b948d54d0553f69da625bff682bf2a95d4ca6d147bbd5e492814222527904ef49b9b409959d9e25739805bfd1d38ce37a7779ec5eedaf72ebe8a48c09f3ee0a4fd8fda17699bd1f41c3bfa0c748ebcbac88a004a5dfbbca5fafe7a2c928bbbf76bae1dc45688f6f32c8cab44b6ee46a78e376b5601f51ea1754131bc4d88a59df61a84148bd573592302811d6b4f3c48111ce1cf81136528024ea3acd8933427e52a9902d0f9a3859685c0332d598ee4a42eeb13e8d0a37636a8f43043213e7d366820081b5e67f4772c3d0e9649e72cab3804888923a0b1a787a3ce9d55bbf1970d06a5cbf0bc115e65a2ed9cc76ec3192d6b61b9c084317be96681e634c1ac1e7529a497524c814f868232a504a015d5fcd1046eb9656e9c7219032315531d31ed2435b6de032756b24453af5f67a32edd9e95e821344f5d3597f3ab768aca5612af07c82e5e4f4cd18a9a8a8a23db82d4ff87538b3b38d826486162bf5f7faf4599794ba7573e39c14a30ea2ecd00d9a61e367adc95f84c88dcc89d50f709216f2040ea9bd3ed9d89a3118b2b0eac770f620ff5db44a0e7e6ff952f3a91b90322575214b4497fcd3fc80bce532369f5fac9a09a9762272c86f3f0d31c6723e0e7e7825479f47f3d8070ac5ae6385f632f222b4fffedb92c8cead45b00da4be4ab042f7ba647c4ed95bc2b2a6dd2293984dad19858f1abd2d87da95419cc6da7700b72bdc1b677062e295f48e7f84bb3063145606219e5aaff7561360d38a727efdac4333281456717d6bba0eca7a9868e065a30c431ba184fd42d0e4f864b9e5a4786f2ca11e5542c98de1b5a9b5e43dd89cab908401a225a33d34a3d2219581406c8d390580af50857401134c4edb21566d9dddd16c39d3e2020c308925ee800f2c8755040362ce5b0adbccf7b8e15082fed31bb0ca9019c54539639ac2678ee37702e36b246a227a68da5cb54fad18af987858661ac0d5ab4a6766675a99985c3352dbe136d1e5f36ef57673ae7688011702ee84d3ea0be330aa8d8523818814085a805209b94758d7c7da03dfaad553329acb76ec275ad06c86a1b0bc5b8e9553e5469b3d1878e5aa73b39ac1c4a46ce03b007eab324659fb487e4c0ce852899c145a1cea4eb0ae4b1993d19edfa862dd74ebd45680a2a91d99537074935e0a049c7ed728fc72f1d0dd46fcca03ee1202819841e3c425e4f6f706a48521ab28dd61e6243be838f0e196f91eb50e3106864d4017b4bf92f7529ad54455d0a301a108f0be2b6a35cfe573f4ec0bb5fd79cf9568edfc836a6a59a8d8f11bdfb737031856ee548ee357b0e913451862b21537af01ce8b776fe8de409508b141923422a02b49641389e9eeac5694340d2faa2220772663fc7aa8abd4ebe241ec4a6d9ab27263d211cfbca3633041e7f675f74a3d939cb99b9446361235eb34777c5038f15eb5db96746ed62ad3c902264ede4b2898441102be6a51bc4941056ffbabd01ec974e9d942ef7fe8f23023e5dd8ca07bb45ad940be6c36e08fa069989a27718c28d12497121ab76f80d8727acf286589460dbb6dff7d59b0c64e24c2c2244093c5ba3929d3a23e935657bcf5ff8d35bdd42185d494c7ce1fa76af2be7d963641c968345cd7c5cdc0119eec1bfdc2b416f82054aa99cd1dcac2446d3c87538667df521f1d02b91d430f1e340e59eb1a4d928363cfa9e29f16d327ec027995776e426e3ec1b5a8438ff1d4ebb0e607fe8475a9ce0bd2a3ef27d319008ae05157c9b986238e38444b88954e97541f844c8596006c08655e6d1851afa488fbf26a9ac0eeb7785790566f22755481ab02b732a976e64e87b4d6aeb32413a92e956626121ab51e4aeba02c4432b534a9c2844dbdba2cbd91a914aa0ede6e65743cf90703345e5c350c4cc59de836af951ce3d468866e95c11d87beded5fada39fdee89ff7ec7b24076f9944c632ea377e633838e1a315fa1c857e420389170d79365d03d739a4b2e9289f2596a1b774b9692703699eb3349b00271de0fb4a65dcbda16cf763bfe54d90ad5e363c51f5bc5473fd5275007feecc0140777805f43f9d402974d6124b4f9b5b8a578a64abf7d97c2ce1cb4f999b359bae956a4e22a1e53b9264fd3685523fb69e97037cefc2be006cc444a34fa55b3741da1e43371b2e6668801f2b82b065b7bee328379fbdcff14337000991239a87a5f167f96aeb698862f4d63bcf9a39bb66963eeaced32376e2bcca0c7ddbe0f9712dd3b244ef180d034e74533c2ea93bb2bf43997d5410531fc4cdc6e0598c7665ab0759289581dd2d7b4af0608363296f6c558a30cf09122ebde560614614fb48e76955a89fd721a20f02691803e0406076d4ab2084f31b8ee9bdc5ccbee6683a2d525d45cd44afe9a00dad093624f1a5dbf940f815b3cc6e5a5f056fe58a0b0738e367877e761e07bf91bc648d404d9665b6173cc2f63e865973f3ebf2275ec086565fc8372e2551fa581365dca8b6a1e2fb6ef03d4237fb6c5798de7b139785f44135d022c740cfd634650d543fde49927f8a3c6596c8c4fe8ca15b008d7434dd5c4e695fcaef100b46bff097c7214de6678430fa5029b0d616ea3c05a64392eefbb8ac13b11770a305f798adaf1fe1bf65a0a837867967a016dd301939f6bfde974cdb84aeb958c352dc8f8f7973f54364ba30c1037c46ac27b794303c27a7243db64b69f8113560c60241ee2d45e8234e63ec8ad876eae6964f0dc0132190d5143e4c5c751d1bd454e13fd2525a752fd31f8c0f22cdc636c241d4638c786c87a81219819838ad67498c58ea06e1301a346b21c1c1a4715f6a32b26a2edf3e370df1e2af6a81d80a46df008f2325bce29430d50b63fdb07907aaa3b50cb40f48f4d5b47dc01e27afe3193c38846aa6c299bc08cfa77c06ccda983ce7d721b039d865681ad69747aac35faf44b4083ae7c7bee5c357778a7e8b0edd1e4664f0d49b6eeff91767255881409f7b48526a2b07d0d94fddf68a34007b51d222472b6a300862cfe2954bcb32bfaa7766c721afe82a33b24461af0ade16ef2957a907437bd39facc997163a077b2495b097ee7174887f2ec9c6138e57c26091a1d76c5a60688bf4fbcfee0a476b1c58c4e997429830e394d4b1d6ade4adc597447257f48f760cbaef84032c163b4b64e6b02a17b1434f352146545e705ea85a61aa1d85164494e91e228ef141facef762325cfd7297ab09ac651a8e98862f38b8f2cba214971e7e26df8b37fdc47213cdba111426319c3cd09bb0d9b9ec64e987a39f1b9bad279a47b2dc20474d6494f675d3748f4bf6172a81022d0c9448cfab75ed9d7e5760d367cb3b965cc4f03600ce17e2d20838c953180401a693e741fd7a0da500979a02240ef79150b426670d1ff70d13db161ccef73b847e581f2d8048f01231d5406f376c8c05b67201648c9dd4bd4a76081a83aced5079833ef71007db5e24613f1841fcb225986cfd8fc6060ccb0abc6ff3fa07f1425b2423b5a862d79bd12422d41727aac7de41fd57cd2acf4b75cf06669c7b4f58b7ddc01e0e9ddae71695c7e4523233ccf62592ea6dbf29d67471dce74e81d6459f3e7186a1201dfd6db25c4f0f4d7bca85dd895ea86bf49712dbd95a470c475996af13bde3bf7fb01c9d1e2f97add25d559b2c27a13dd4129f8ab3be31e4dc273a5771d73fe8c06aa4537639f5543b5596c75181c2b45212a0a51a2f230a7b94d3fb9635fd34fc5c7db9c8d836dc9b4560ee71c0de02a3d8b690c22a96763e4783781bb8ca28b68e4ed4857313d7ca2810395b983eb122f7b632e7b1ed7c49761f09662abe164a2a5e418a4aba27607da96ac2a06af4229d89e5471247141c5ce3ef1e911bcdb9cd5085ee6389099ed5a9d209937d9da5e0b04f9b7ede9939c2ae2ffb710e8d7cc602db6c7bf5434a68227d1832b06a1160263ab2769ea22b78a95653bde0de26cdb9e3daf06cc949b13f9425b4e5e4b14d0575b852d0bdc6d6b65b5ad73b6d7f9e7759e9465c62f6b631b1b891a43991ead01721ab44614492c4a5c07f5121e9b9d95ae127850ce16561b030cc08343f10ba60b35bd86d6110c2c985bbc1426484de02f78acc2c136c317085ba010d6b75d283a27620b9d39c764e3a6bd4ec4f5df42c4412e30f274f53bc846fba2966c6f0e2c3dde41c69d60bb92ba027573136a0abd4a5502c254f5cc8fc01eba35f6b34ba46aac9351b70c9272b99b921f3d8b297dd3f4d560e849abb4a55bf2b455fb6d3cf9cb1bf83f44fc483cfec60b46f06f4b6f1f20f9f20cd508921f98e081511bc07107df2facf741b3b8f72111bbd93ed0a2b8255f66e6eb7b001620d4109d25c5356fe82990098e59584db0476ecf7b0347a8392d56acaefca465a14625b8429667342323620398ab825367ca8a8cd44031d1bf30700a73787e3d60e5e7826167c99c5c6b0f7144763d99680d55d72808a449855a7eb27b99d0a07639b8684fc770d60e66cec3771b8506d694271248efcf935961f84d5655b19e6365088edf640cf8d41e57f999285f9232975dd8018951bb712e8b12fb9433ab888da6062294abed44d5ac8687f8f7dce46cfe3e8a7840178867d774a9f9b7cc2ad45b1bf9447c3d05726ddf34d32400b726cc748847b6939b836aa07524487d40ce6dfe9beda1722121b63c1673e59fcbdd435772fbbda1ad0cfc1bfc982fd87c3835c55769b1468147859897a4b44b4bc4decdbc69610c29b6ba2074538807d67b9c03ddd7d5f357369b01b3f16171b439b7da0166ceed87d2da890d2ad9cc4753ba44a38699f1990dc870d7297a4e193e412d31f1f02aaf642a06ad56ddd7d7793c3a4c1b3a55acdacee2f80663f81f6649af75aa313ca9bcf77b2a0d416aec51e69690f3009e42b2bdc6ec89093e2bf7f45cb4881e7fa64fd464f9267e94380ddb0af1f3e97ae1c57e757655ffcfdbd026ce6ce208a4b3dc98ca1b2125322485c5b8ab46f8d6d550e4371861f205b858cc8823ed437e1ed095f0e33366451ebc697a0ed00e4cea58442ead47f91ca27d3daf327a0bd0f66e5ef3a06abb56f6f58ced04413d900e70d36d6bc0ba7cd4cbaa5f01dd975f9930f3771423c76737404228f3254cc7e6ad2de3b24e2feae192eb1ef7c50afec46d40b7edcb3acd5870b85bbe704a13a704a2118f1328f5f1f1785c2625a8b1af60820a3bed4483c1774f84c82a8ef09e2b8ac287d710004919437f78004a85aca880e0e156c4fc2ad20e9839b79f51e2b11637720cb74b422a840a8f12667e4c2f6991777b60c110528e67db5317899e3534d60aef93ff321ff291d857af1b3eecd2e14767a1d50b3e4f7bd5f064c2131bd93135019c8000c67b867d96d023908d80e002810cf4979ed4d6518b63910a17a7a13fbae820f98613d768883fc09d3f68e387fad4368aefecce4954552465445b8e02867e360750772aa96837f92acc7492e2878b5aea3639e58b6ed1dcc4a178f53ac594a42d83e314c2e76bf63ebdd233a10ffcecb02d643e21df61aa5eaff3c463268014ee323f933bbeca1fe6a40fff18105544ad2a826ea73e98f684e9ec897a0eb54e05812a942e4385e7732b9ee756e70ad73499e85d403eb6edc0f9b586bc26a27bb9f5bb13943774dfe031b00d2dd918786a1959d22f56c8deb3477a5970f381c6b849eefcff07a9c892022231eb86afdd42427ed2dea66b4d29a0deb59d805a219a73342ab34f33bf15828956091eae5dd6257ba39d8248bc6e4674ae36ca99ac2b2f784f07c382c3373f982e13e87f7b00d14996983db46d64b8ee401bc88c486b7a5a337820f0fc2fc7812b5484d370f6d6e758a6a9b7381d16fe0c9d69db43b74fd3b67f4520acb90222dad22132bd88b6da94ec042024a909a59b2095b3fb65b8d164218fbb2f8201979a06036d47c4394d5909cf9611d343f07cc9ba420957941fa425ed646458665836c59e9f1c313acfa5419eacf3d6f9396315aefd5d77b4e40105d81f9202812a7fdadc7130458872daeb7596304198aec4183938bf9021a0afcc36106aebcf110a8fc075fbc374b65168713cdd234e6d41dc9f5e2ec9d8802b12d476f0488f52fb1f8e7caabd9432cd9567f3d70fbb08e8561f5c3bb402fff9755dde641dc766dff5ee7e5416fb7eb8f3770d2bec3235d5ed47cc6a6b8c22095bd1ca22eb901b859c96991c63fb62e228c36be1c5ad660c9395f16bdaf5128aac27595dde8529a9fbed278ac22278618af7bfceeec6e0f94f671d8e9eb02bfae7b7ceeb99dd7c09f4b09c898d149d97d8e97d830f65ba51881177b584be84ef2651b398ff934dfaf61bd0e936b770c32bbd0dc29d4b96e1d9a70fed8c6809123430193a5de0055626aabb3f32dc1c9e580224f9a88c4cf45e0aa183067d515e68ea49af9076594c9c103a8b992ffba66f7432abd5b8396662aa3007cba65fe0d1892e4c2ed44a871512601bad5192fba08d510269bb8280d05c7f38e64514b9d04f24573b6e7af664f5cfe50fd675407f92d8c72d760ed3b23b2709f42dba8b2e153d99d82988246e8a45d9898864ac79127820fc1bdb6ebf6e7ecb243617b016a7eb11418ddfe7a5e1b4a867723e6d7bd21d6fc3d9f12c5a112188ea8e842ff487511ae03bc49c918e46bcb2ac340b35cda3def82993dfc8c6184f755fadf76a3ccf4394701ec0edb9b96f70f613c085d3b54ba378a74d5a50f2ffbf07538447e4899214c1ba4ad24ccc687e53499c06aed35c84faf44e22d359a32b0d44c4083831e4d21f5703135df149c12e0831ae4bcc8e0473cc6e7206a2d57c209b61e8281c84484ea44cf1d7f0b3f619fec05b78ebdc51105523fe7e840933b567a186bb51eb4ff5a808fd7bbb753841453defacb476ff41a428b6e25feee287f6e46a4378572a96b902b914352cc4e038f49dae6245c1f6ca4aaf55280723ea89ac31953bbf96d7ec08d67937fd047967f7ebfb84724df1e7fbc2949ef8b5047c8d1a8569e6070c6d38a1ae647ac2fbf21968e600b296c0d3d263cf7dd23520e2d636707d0b3b3586def21ad054bcc1abefce4be197216ffbb09237b0ab60ec479b031c1ad40c1b74a786141d76dabd7d045828ffa1301cb424f35804fac1383549dc32922efddc9b954d70b276f356b96ade4ee25d49eb81d526a05b65b894f569e9ff0e9f364280f625169bb71826fbe10bea587a1a25ed0bc9994e0c817ea2e66e113ad1ac318852db62b0e361d4f7473b6838b5e6cb78debe41fef8528e36e1177762997ce63ff0786f58d84b15c4955edc93dfd2ef8fd1a4c9b4566a348481b5133c243fb53018fdb60f346c690cf1e368abcb70805e22461985f6c98b2c741045e97c29c84cabbbf0232ee78bb9cf608178bf5b142ae879cdf100fb1155ae6f8821b4bdc34207e37e4fbfbdd885c9171358dfd182a9a48f6ce6e9ecf4fcf230f6335608bc292b2dd848bbd806d4aec2f69d7793cda21df9e8ea2658e73455cbe70e2fda4f994b886203d83a01b760b722fb3004b62f697bfb7c72c0b88295474f989058707151acda12e231a53fe8a3fdc28c4d4f384d9e0b90cc9b4ac53db9cf76c1c5df1ed01b9e316b47c6025c19ec6b8ee1dae0cdb562b05499531c57067b478c455b50ca18c9dfcd7452ee59cdef962761a68ce289329b1c25e569a4611402ec1dbe46276cb41a4d8675226c167920609c0f10789302fd5c156284aef86426fa636aaabc04a1c782451f3c8e8d26591e3e2345a0cb2547ec1bfcc9467bc4df4a78513381c3ab27425adf647c286aab3bca60a5abaa4a8cf2345e362bb7b72e305afdbc76e8f8697c9ae3463ee7f3eb954619fa115c4ea9a0cf447099ca6659b29ab87d0dd7aea1248a4a189697b6097b68e895a27683c11a5037515ff9afeb54b2d33461c20b2c4757dc8e8ac5de3f70b95c6421f7a6cf6d746cae82d8bd10e98a6cfdd3f9f82f94e4ec0614085ab55c5a7f9756973a95eb6cdd5b65d9b1a9947aaca41d7a7be6772e7487435ac23fb1d343490700c61203cf83bb91284d905989b04366491520af190bafb647043f81256c4dd252340902009a26abfd85cf822bacb0a84d726635141f135e0875123d9ba9fce7219b49b6157105718f9498e4b997760c64240900b2d945939af306f589b54d0409ab1d58de786df68553098f5f2a439b8b5189312e9d2df87744103ec24d54c42d6bf4ea8aad715aa43dd0cae8204bcd714a5f9ea8fd956f64f0c05be08c1ba55fed814383c5fe02114d0c28570fabe6b58084a7791649080f2687a6975a804cb96b9d72f727bdc8958f24c06f0f54852b85895291c2045ba032a628b16cb3ff2484b18fcdf9963f1cefa1598573e7e6d1b1524fc5a7bdb7f40eff101297291f0a0105bd51d31b3862384bdc7936cf91cef0fbf3f4bf17d91857ed03e123647f0d0e050006a58df370f1a4cb624552aab2246c7592264e6b4322796c5a7731e599f7f003c9b019d9ab9870829f27a05697dfa48f943a79868f2421a50116383f658c18cf0d01ec6286b87a8634568e7861d14ffb064b3a3ffe4711ef6adaf35d5b88e4f79e78e06174a567dfeb35e07af61a4004ca617582bac20c290ddf7c23be4043b11f3f562ef21a909305a80fc808e2a6fa5230947277a4ec84ccc53c974d0a11506fa75ad79b27d05bb2500a1542bcade339fe0e73592d61b533cbe10486a5d844a172ba64cf76dc0e7b28c459ead3d7dbf4f554934ce024b4e9764f3dcfebaa67053fae6c22cdb31588e7e45c900e0264ceb5204e81781c005b19de83e345bbf5d881981df98af9559a792de96ccbba9e69799d8ede093fedea9f2420fdd3eed0aabbad2475cb747c3aba0dd884f4c5d41080b2c1f0368c61eb825e4748a49f719164e5baa17799c40980d6d8b29b859c983e4cac0c385bfc1dad7c3f5dc0052a51f118cc6372dfaa705f0fad1e2f7366402233c5992c3405ee4508540cd882542a47b92ecbcaed758f0cb7f14de780877f32cb665d43886c36fce580b46fc4da3c66094b437e8075a745805f011a09dcbb5b67f176640c50a814d1dc1064c05ec0d9979463c7f6591ac4a158534de7ffd55130c41276a7b0fca4320634b1ff947a2bfb0cb2f941021745b463a297da6e925199b2f92183e41e227928d60c886da01b829af1227980e8df97cd3d7596625eee75a4a42b45f0c6fe75475df2802d8e6a7a990676fc0f6fb26a3e115758fc604f1af612d5c1428d385a13a0de3d9e5a1a89dd30867e759b2aec2b24a102eaeecb06cb69575773016e922251d8091ff434cafe95a24fa3a1dc17fcd4e9e0ad12ff82ec7b3d3df463fb038978d606813658bd91840418fa09410df54ed476a1f3a6bc630e99973b2ed2581226a1da52de201ed3fa0f9c7954d721194d6e6af0925dc335e70b2fea675b8957203ee6faa56dd13c544c7237618f58b21811b2443dbd71ad2d0e6a3a99f0a5eb19bda682b418a928ca80952de5d73427561c7df7ee3296a03490c94fc9f3cba9a8c0fba7b50c8136f5333911ce25c69aea7ed8e04252d8f28faa635fd4380f70b89f9d11ba909a5044d8ef7c7aac462d420e46219377686877793414448fe893b74d1feba448747f1d9c5efd09ea4e3365be343e7505bdd046528439d871e266a8bd34ffd67103942524a164e60704be3bbdfe4d8a41a27c87a959a53b667a9f85a1e64a868f8c232e50cbf8e475565c4e714dc1bca30c30410f3e4c1086c9b0f4292790fc15944acb37c88832ee266dee1ae49f15471fa1c4b483137887d1bba17c53c7a3a040b7db613087b1957a4e95be1cfbba53649aedcebdca93db0c20a19bf9ca739a9a8603fd5b213e31431ee2f62e2b115b217ca1c020e0dfa8f9441f897ff2bafd72d7293713c9d8b5d243f8a9af4103826f3d753f516cc8e01aa7b36b86fc54478804672da07604d913e7ce15390ac8c7d3c07c1d92a66aea696ab02f20f586290e46680352ddac0ba9289694aff7fcd63390dd08f644add05ecbfe0ec08994a91ee38d7893e072c1579a6e6dee70af23a3336a4ef3a87182ba324b8e3fc7abaf3e0de6166e500d444216cc5fdd16c3b1149b7002d6d4e574ac8ee20bde50b24e171afa3f372fe3bfac197c3ac29375e11322fb593701563c8d70c137e04d38274f508584deb9efe83b7040cd1dd51f94a2cf725319480a831131a6f89065fd9633a40d70bfb46596cac37667aa29b234b3316c1501267b4c45a66db6264e24af6faca73b877b16c248a1e0150590009ea16344d7d8a94773e314eb2fc8da2c7df396696ae55f692ffea32dec8a5f0801a6cffdede05508d64ae301ff69dacb73e283051e3135e91f23a2d0332e83199368b0b5d08bfad4c240b885c94ead7a7a9dc44b45e2cd867d9defdcd32ee55452f166e3a24b77d3f3434e15a45c00ceaeac95b8dc25ea9708793e5ca12e4bd4ef28cbdd9680a602ece34880c0f733f29a69fada47f544958a61495bfd633f62458de3a011c1bd29e3914307355a01475968168aee3761a9b932e5932ad86fbe2f7da588811835b3e44e195c79c709d3cdc71a4ee3a6e372b78c6a6fc2b47a8957f68bb99cffd9614af0ff6dda6d0e790f5cd42798a99f199465cbb4197c9e70d1760ad21baee8c4a52e93583f2fcc6c81bf6078ccd3bc4b7dae6b771a41ad41d2ec8966c26ec0b49dcbf9a3e9eb941bf5181912e1ae4a073c925a8f1d6f6406f3da53f168c9f18b0de090367eb644bb985f2a0d81db5baed2afa533be9330dfab9edf75ce332ce1f0911b435a3a636dfc698c2be116d51bfc714730f3d735b4ce0f0cce566ff41c9a58373bbefd5583f10f2cef8f8abdd56813c03619296922e44f3c7db8552e846934286376e09e479dfded09c634f2baa32eb69a381111da3128865e26223772105ebfd7fb5f53d1e0c58b0cbd9b6a0a46916703003f5c488fd43a0b07474bef88920054606577142aa266fbfe71ad9258050072cf9b35cd34ba0957e30c7511037e2cfde3f150ae2eb1c518e4095a7e08f12e7e336f37b52e5cc8be7f18ec569ddac798121533492cd2ae97425092bf317f7d4772305d7f3c46eef8ff90c92de617c92dad01e851f636342d0c103b686f6031dda37df35787ecd0deb62d291e6ad6130fc6b00508a154405d75b834759f0d4c02f673ba4aaeafcd09ecfa83399d1a25149db3f13d537a972244957c736fe124061e54ec842fd92d8171850f77e7b44d87cec8ff12dc9048a58eda03729b852b0098480d3b576e25d427bc9bf83c44dc65955190a305adc911e0e22d287bbcd90674bf4b3884422d9e46284b551ee74c01b74da721a1259d03dc1af95c1606654b3961c4a3317e2a62d208d96135be1116948a66c2940b911d6bac69e1b5b4ff83f76f506db4a41ebbba662c28f33b205a5134b672d3d14abd937b85166f8302d52495b700335c1a149273eb49080c2d5a71d012a8eb92388fc1afb6f7bef050cb6732ca4260c5ba1ab2dc3550252cb3759e9a6e756171dd3a1583df359044cd7aacde7f663363fb4ab38cf7776b9c0af91c21c8237cd879a93b45e28138279ed55385031042e5f4bb64d24b81b53ee7973a22f1cf4150df11e6c13adf61d458f616eb5fb5ec076273f992e6f08d721484c92acd47a0f7d1536c2a527bc2374986af1c1d55973a9e9157701760568a2ff4e6024821f980642cc00e0855d7d36c6658892a56278d9c45e0b7faed34d20de02d84f7e28dea3b818691ab4f3474b4b62a21eaacd45f3f7931902383c5e7b646d2796898b9fe996901b9f8e3413aa9a725d59b0b084be6b3e361a99cb1b1e3c199cd442f50a3c205454746016433f8962e6ca9d2fe083c3712300bddc062607147f1b4a455de6186c68c50e0bf2165bcf80f4eaa22b49e354ceeddb4011c76189ba8c7e156e71f1733541e2e953167a44176c4186e2f62fa6529a385c72833d1444eeb4158680e6832939ed9bdc6a3bd091328ecf72ead6c0e9aa33d651abcd158393c72d24548a46f1681ae73ee960a183fd66ff7325633638675d8070670a5a742d4e7ecd3b159ecaec37d5a025d3d972a1f24ab276c3cdbf27c6e5386d03951e52b713a9c9319ee3a2606558401321ee78b355137b03ee69c7e0936526f6162daed7edec85f2520d437798d9de4496bfef5d95dd03c2dc0969d32e1ee4565087da0b7e09b4123e156d338743c4e4e287ce0b79e892e662e4d01b7cd6aee1fa1bf47787b36bd31dd27cb292d5c83b39883b63e21a0dd6084aaf009b8d56d19047284a05dec396e5fac3c05223384cd04e587c10c186c890275930944144c710d001c815ad13ddeb91d3748c70e73a5333b5ac95b0f1cb7a17ee6284cdfd1d940ac2189507c68886a80d673ddb2e9d23a40029db1f19bd7d83effbefb4154cbef362466a2afe1315531bb9c2604cf64b00dc84dccb9ef3b28af9c731764b7c8f0ff19b3dc0dd81832bbff3d3d405f344ed02b5a445d117e92327a326bfd6c2a99bc6105495812d50b549dc452df6e8a52f1a94a1f3850423066b550af9509a15a7620a82c1f0e82d1d472c41fa374209c5cff81dbb711cc94fc6ba997655dc4fb40d677cde65383f76257d414c434dcb69c18059be6390d8627c71dc48f570736fc4dc35866a7257aec10b82da96b51016d996614b02896a2183656d41fc288c68cbaa60a2bb1d3b5eaa9778acfec22156489df04b696134be89a5e19c5baddc35c6d9adbe256855a80751124ff5a121c26b5ad01e456940768e39b4cda0d33c7b4b107e500e7e840cbfbb29d3330cd135116bbf5351530aefedd0f7a6395baa19937d3356b6b0bbe7c728e823aa2fe5169108eebbbf9e9fb0254837c4251664463367125e7d0b4199c2dea85260cfd92ffedd8b8e03262ffce4c738ea75ce474dbc1cd91471c49c185af3b49e5ad8d9573bf6daea43f887cf1aa20d67af88fc02d40f28c2d250f4f49c33eeb90362847c1630c673f910d8165cea11ea91c2878705691d0e5b04226637804ea748e9a5becdc1a79bff954a7b96a295a2ee2967a198e68282230d007eefb68b2d6e36b0f0d3b253353f41a667e18e042bf3b94fba080d7e261bbac73acf4d6d87562fc2f8811e3a816abbb2cb378240e93aece46ff0b6d9aa8e970d0903bf57bb77d62ec01e618bc63dfa223ca2d4392cab689741799de346d39ffcc2985ab4bcbdeffcd4dc39a17a2fe636616a1a577089af99c02fd0f120646d917ba4dc64ad8d5ed28f018b29d230ab7aa42a76fa7ac194df14bc6f13a2aa646e883dee0153bd935048fce0d5502cc8d62c91dd8481af68885176e05533bf582fafceb04986b8b73c6573499b62aaf0813ff489c164be02bb4971f1363c89ce690a132211144c04891f9fe36494946e018c39c6ec1892b4d1ac8ba91a100eb13f0060fd6609dcc7aada699b9077cb6efce51f2b0a30bf40b4eadad31f1c0c751dfeec6ef5af60f363e350164c856f04f48e0cb04e8ec01c2fbe36ce957035e009636f38eb8d2860344bd00d37c5aed5ea76943e409c2535a7cdb58685839e7190e51287838375d3962e09188823ba4f81412b025b68379bb15dc1ceeec8e5c96d35996a2aac6265811aee3b09dfdf3fadb4cd2a1462a181dc3255de2c82c8b3419adb26f36a0c2ad81b6883300438829b716a20a52b5106553316ea948523096ac0eb09e0d0d0d3d4d5fcf337511ce580f554a363c29c56e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9fbd34e74576a86dcc3dec55d3a0aaa3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
