<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Solution for EXC-002</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #217573;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Solution for EXC-002</p>
                        <p>You shall not pass! Well, unless you have the password. Then you pass .. or <a href="/courses/PFLS/#exc-002">go back to where you came from</a>.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="SHOW ME" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b11e8c12eb6b3f8b0c44968fbe5404d1e5ee5e40fecf79a9f0ed6a749498398c1868007892b38b43c5e221f1bdfe1cfdc275cf57c84b652ccb21ee6b3eb3c481ba20b1693fde26139f7b0006b6d6e0e9ebc6183945f2455885f6c8e823a205526ead8b51565c44a74c5fa269535fab8d513132d8361858f8f822c5ab7c6261232152fc7fba2c1e92481bea7c4603c3fc4efa43aa3517ad5057ea942767878b6a0bee2cec306ae6f5a3a66eb9ff4f8b280725b6d0e6fbc557cc92642487fb2a2a5f592ddeceaa39fd38e9b80170324d7790428414f6db2c997c6b27866dd2b3b52b43959bf75bb72f4efecde38e406bcade5705dbac3dbd395acaf21fe2152d9390c41252b895519be2eabda4e142f66536dcca467ee7a39bd2eeca44d028f15ae4ceeb85ef0b8f9af802ec80f96fa72e1cec1add73d875ecb52b651debb076bce7576066f24af37aa8e721a05d941c632b8d4c6b8b73276fe22a622510d2e8fd81ddc3acd26d4f75b50e5d2c905dc6ef5470acabd7f9ecd9963c8654123a4c1e19579055c80e23dba3a831af5b77409f79ad08bf37c166639d6e5a8783414f5db65ace41bbae7122bfb157f5e1cfc54e9f58d2db46e5ce2913e49c2f2c1b8254f9851506c21670212fa53d1beed079a5dc87c052caae5e51dcefca58b9fec3db3aad429f57cdeb4176c5e01a6c2af2b97da5bd323437b826c49b094a47e68c703d05a2d7679f1e60bc0bd350de299d9506235037efc18a4e35211ffeb2776e654fe7d2a2ec1d9bea9ebbe4a49871c7a163dcfe7c4560a8eab2cd8b4870046ed8cf169497194d2a6e5ac4dfaa9f2839f8efc5858f6fb792be86c761685c96d1c757987807001e980e6f79b10c420fdba1555f806aaf08f550aa74e73e13f9c384e0aad3b29a149e1de6ec37eb2e2206fda18e1e917c57131ba497cc811842979787d56752edccc8ce6253b970a12f7c28a3af8c91adc2dad5e766bc25a660353739109df2f2b357c3b61adc09b2cb924451954e01a91f978e50af08171bb6d064471cead6524f0e3d82520316dede5b1efa8adb34caa6a68dc74ace7f88d16ab24f7707164876cd5d9318f60e2784bc7783409dc2775c6a9c4391f3fb0f06b34889ccf5838a7f50aab50d08f37cda1df1cda67b68d7464ab8949acb2bc7e4d14f5de6bd5a3ae8f1625d2cccba259c9534408602ade4f661904d1ff0d67f079761eba9d3040b95b93c09d349536292cead296fda68902cec7f7ef0cc218726887bac0c0515c7fc13e023d3db6eefc809520cf6050129e01ba2aec89062572571351e6023c01c9978a20aca93e5d84c954beabbc91ee8812b078d03925bb5004ad7e8e2be24e851097864ae11fb5d4443cbc34d6755d8e5144db9d049e9eedfde0a09f11867301a7f1466b8bbcec36f2a3a95a58305f15180a63ef3cc60a2f8833195f94135e04d364e11c984dd017e1b98706f2ee16c18eb25cb41408f8fba1c01794d8dab166d8961ee3137119de0b5abd8cfb870134b26c54794595c972ef8cb73df85a78b16a2a8ea393daa52ab0c267abef8dec17303a41d0604d4bdc055ccb99a58f452743856976057c1200436ca18d22a6ab07c6b9e3fb3e5dc0eda5404e5a96c3dd504eb56ff7a516d5175a843cc38c8a73c67da3600cc99fe2af92a751950c6a634b4dd3eaa771c3b956cec7f837cd06139885efc149d99a9e0aa53ca2b1f37c6c3e42ce3a63f03b4201ee51912756cbd58cc0bffbe3c282f12118e096bfaf2f0933239ea4e1d005ddaa510bdeda1c2aa41cc80b1358ab7dfae1c8ab6b5110fae21ffcdd2dacb8ce72fc069545226c9ba7235b368e8f4f694e70900edfee7c50f49075b9c17b82a15a842235e004b60262eef89cd249f890550827fdf013c3b6627353b9785f93f511e98a089f01507013cf952749baeebd204c73c69cbd8ae268f64f1a803329fef31b0399287f5af822786090ad6d5d256400ef016b7923eecf38adea276abd1e211087de56129b2cd3ef4d78ceb0be4cde549b3a677f502df3c9d5824257df5424b117bacfdb9f071d3c4f32995932b24c67cd71b47f1dce37abbb1d5b7d3171c29f9da5f8c4ef5b307452dc6b406de93904dc81ce39633986c99ee4cd31378f4acb3198c006a30ea8524e4c5888c3d9ce95b86f8dc28906aaba3f5b78c0c26e9e138737633da75c475fd165bbba6b3e2b7b4de250ec9ea84b31561f9b6e3461f36294ffab129c30bb298d91962e10515b07c2f6a357c77d31b835f5b01f280977ed251617e0e4d4ae2a6626a02e25765b2e3089c15ccc1133b568e440618bc6f086a1f812f183323e6e8c795e8f93d75acf7ea139ac1e9a6ed34ed75846a0d454130ece438cca8520ffd2c14aa0f16f6ed604b8d0c3fce253e8f1623b71369bdcce8868f913335b383ec000e55bf4be6bc49b756fe966230d39866aca5090edda2cc8e75ec397abd2b613d7f12e6f7ddd20f120d136ecb58641efb3e2c3ea008389da11f1d189a59c1a9e388099464006e1980ba536f6a41beaa9e3a066fe2c392f47fb99cfd64f99e8f6b7faf1fb44b8101404eb32ec8e90f7258f91bbdefc26609a74bb1f4f5732fed3ec44aef345ce48da38080a5fdfc10332574f74b31bb6975415d03956c5e651ff10acca59a403c82cc7a56f731fb609002dbbdb8d64ae5f1d814c21ca24d8671b545284adb8c6a9c957282525b37eca95f2b5717445960d9222d44e7c019e1f3138fa6e0ff472e2047566db82d347f7f25014e9aab447cb7a09330d47db86f43746ebeac1a6aef0545c44ce16d28de1a38679e03ed91c5d0866447efa4cfbafb9828a259505cd6797dc1a4b1af4d1dcc3597b3961460005578ca785de70aa205e771d9595a33a58ffbcfab7756980769c833f144528f3af99e5e0a603fc167f7168c8b6697d615aacf2e88547f3c5e23b944795626c88a313937b6b714bbb55cb57dfa6a16f45a1712c24b12aab06f8cd5c200281970e9e57f274e70af4e00fa10ec1b7d56a27fc6882f2e2057d1154f19d1cb31545de20645e5d5c347ebc96dbf96503cb6b3f755fc7dcb430063a83a47bced47df676e2507144374cd981e3200ea92625445f0b8cd0abdf6da3ca866100b928cab4c4e013a852511142b7868a4648c1e005248df4b5a87b90b6a5bb6a0434b2f3847cb02108a036c4c73cfdab87a95a90b13d61bb191788cf5954bbb05499b2bc1f854b78cf2f93354dde272f87c9a731652957d4e23b391568eb8034a3e6fb1d46323f3d0861c7f161104d3c9fed03f641a316b9a4a251c4a422640e85a8ec4a1b1d6ec87021ea13e9a455ccc282f0c74b930e17785ec97b28dee02d31f0df7053d38dea4736bf32f622b65340e0e42a6db00d6ff9d92875321c464221c94c0a77cadd925f30b8de6b4980d57f0c64495450cff6816c06b230379178175437cd93fbd79e157f07227e7cc8c02eae766a29b27f6199b0f613cc31aa17209eb43f7520f2a8c2c598437438ed67d2cdd50440f566d71b6106dae9cbdece49a8cb8db534356910efbe9f5b12ae0d8e5b289520e896f82864bf89d177c7d52ced9d3a5b8918eec9c5688b3c04dceaeb6217a8d29959c9d984da22390a7d44d95afc072d5b393f0a9ad93efcaf280f0e599597ed80a7adced29bd4dc7fbd5c50378b3e443ddf390877d7bdfc583d8d0cbb83df361fe7b4cc87ae1d9a6f9a73d15ca607c8ddb389be06a27aac6abcbd1f925ea1d70c4f6f434afff1cf97a943f1f7a860e3bf59463f1e45da31dbf754f73bc346c6e0b6b1b52fdf547be0f4dc8b3e4adb316cc71f4373deb1454b4081875ca6678f2910b7ba8275dbe66bbf587287f39bb0724821f360be0411ac3e84f42513b09dfb715f422c19732c889d1be5a4c543a2fa76129c768024a24887e7f5903d85915611ec71cfdacbe407b00937d44ff550df44ed8cd431895265e67f4c2f3a1a0a188ed2cb4b38579c3b2b9823b893ee54a3e4358b20ecd90a4a38cae8fa3bdf992610892503ad043a89698cbdaf4104af83af89d975dc96dd5db0c581a43a6b20246c8abb413caf2dac735b87021351bac589d5ed81c9ff4f22e3c83bea9c779bc66302638aaee213f36c250fe5fe49a20f2bc94a9abada0be5314d41e69fbae0423172446b07c676f0d345e5819725c6f15ecc44c988fb5ddb1a6adec6fa3c6f335ad3af5fe0100c024cfe6d76b0007bb6e9554bdb6d24b1d1ab2db5b88fe2fc00565536190a29fba4729480aeab1e9c375034f122eefb9d70a2463bb57706e227d891d31435838b422cca98398c6fc313dcf86ddff8dbc46512d95287fc652d2540ef4d70d8ebae34cbdffe5f8a55fe245bb2ea285b7dba928f31d37da9a03bc135f2670fdee7cd02e418a2625bd9b445a616a6c3b39c6a6b1ca180b6840f5243186e8a1e56ac5f8fed2e7b4df761988eca8f73fee3cdf74e85eca6a65347562d8be256af33d40a24d530bfbb00974fe18f6a1f2811c217b85969769afd767b5a3dd5aa341a4b883cfd1b330f6556ed92edcffe92bfd40f8b8c060cfc26ce6fb8defbf52154376893054f7431049580478d43f745cb6a7524a92f74bf930dce6f0491f5918aa5c77b64e0f7f63cc69b8f2c007e05c164391529768bbb76cec486dbc67338c97d7b442cf7b5d1adcc4f7905467d9762eb831f70db1736e53dbbcc2876eeba90c6c0db366ba91ba5519fcaa1affe598c82ca2879467a33c0572fcb96e0262cb4a42581d50e2fdc6b57a1db0ef4a6b2a1ceecdc15b730226aa62369cc75ded939cbdd1999d38fd9d6edaf5905f5a11497248efa31285fde34398b8505106dfe365e1ffdcf6a3f2ac89b03bae31c551d9aa8916dd8e9cc9ad9702a78432c49ab3c8ff824960b8457c03786c4f83d8503ae77b465cc095331e2bcdf5e4c3820c15ab6d5e02386999f32f9ab2bcde2a9d546cae75cc6388231f34400598eaf2a1f3105de149258be367192007e131f09d5c2ef0c83147e850eb9d65d9bdf6dbf786460ffdd8b95a5c79c3b992a89e7be54f2509adb8b0b50fde8fe72ea03912c5c54790d6b28e5c549016286bf67bf48523960441d51fb3552af093d0b986ae840042b7c82d3880f6eee4bc910b8b2a0642ebe24ab898b691bac40c9a769213a735bf1557447c2a19ccf1d9b96194dbd4721c6ba24c13a4b3ace82c5a17092a75590a0484416d7facc28f55ae52f99533acea0383e0788368feb419e3fce5f60e5fcd4cd15b27af8a1df8bfdd8b947489e3d49ca007cb060deeb445960c37aee8a7d50ed83079749e23340b620a9fdafe9e12990043862fdc3e0a02e1e0b05e260b32aeed6494a016299c4079e15d36139bc200b37c7f123263730fb6d916a671a1e25d7dd4d2ce6aeda60531f60fca2807ec1a2563543e29beece3a630b5dc55832931dd930cd6ecdf90448df9353f258205c9ebc12a40b4fd87d9660c961f6fc31522eefe06d7803753c18b94df25c4cf7ba236519b9bd4aa1af498d0026fd57999963e7245f579c093d1cfa332cc58dc890a9370d14f63bc645556dc9d64157388e0fa8c8223052e587c13ee7a0c70173ffefe28bbc5aabb6d2717fd6a390850408580e9618ad670a1d5d662d027123ebdc58538d2266232ba2ac9ba404abdf3081d6520d47d6468eb53e106bad69f876ed07ba4e62628d343c241af2c542e956f09a708c9c8cf5211b487bbbaa2f2e5b200751d81fc465240f86bee717cee4084f2258fac96b310fef56162ba1345c2840c01509577b069c266fd4ef6d89656671825f1a5863d2381c87a95544d7d9eaf4329243a8d11e0afb5021abfb303446b372ba2ea36a0025faa0e8f8be584c3b9067eb60ab364950db1104fde5d54fcc52756564fe40d4e0a6d4b1be2a59fa1a5fd2892cd934d473e1682a31862df8b9de2d300f36091cc3317ad6d92554524fb0c1d99500ddd2dea17e3311ebe6937ea5dbe8e7f82f63a715db6f3c7ab5f80057c54cc74c0c25c3f88bc462df4da21c99137447db090c4575ea128ac77d1ed6f3f88abcd4b462d45fc71dbe6e93ed9fa1c2969e9c7ae0f85a33dac5f4b9d12045adcf851903f072730f208ca79e5211fdc6aab5d165c2135d4ed6934a85453a54538a95ce49192b81be19a5713d56112356b50759aa6b26592455d0bacd6d16e7eb9af4aa843b7301f7f606bed0097eade46505b07c3d4f638e972d570ae6238b0a92b364e2131d89756839ad443ae9cfc2b79682ff3afffb3ed68957f1f0d80dabc319f1e9714a934a5f62701706edba4c333423348f8b1215af847630ec039ab640c74a37fe66e8b5f8c225d0cb984a84a35d568938763d72aa1aec08f56f46298e2d8426ce08d2408f4c64917fd7d4270b3fa784b6e2913d72b094bd8aad5ac20c4212945d177d72d9c6ef732ce11d62a021d9dcaf42e29d06c5cc985dbe8060ae058c35a5b389f56d949cf962c9ff5222b285c8c59717856d06238929b9dd12b14db7d6d6cab21607907f96ff237c6adafc23eabbb383618d8c1d90326c8d4d18a714bd92108626fb4a075a5463a574df79ff2da032e2f3a400e79af16c1a8dd5a27e6288774bf29e6fd60fb27f3252b6809e93edcba406354a757b5892756e716ed585484af6f11711b24990c6a6998b447fe5d01a64a752ad8ac5e3f66c1d65847076079daaf455cf0fc7629b4eba3e71fc3695f42636a125e5ab8e079215c54316bf61583fa047c48ba31dd31f62e7dc519975e0a8c9ef2e7604b4e7bc3ea11769de1f183b3a219b907f0e752526993036cfc215b58bc18c7b3ca6ee9d1603331ae932e6d7c122e804814e192a40c2339b22a2ef85b5c9b1eb18645084f8977de2724153933dc68024d42b45548e7bfef9cd09a81ff9ce0329f84a74f3ff1d09bc3cc89a9a57f03fcd382a018b379af8f8730b771a80dfea1a5172ebbe002a9b5022ba2d1a091b4ddbfdc34c4a2f9da91e9b6cedd995e7ef12a9ad7d870c09b57e754b379ded81749628d415aed1788411929325d1001dc4e3a3a7f1465db92feaaaabfe7e8c5621c22f811bfd140c7fb9b01ce7398f257dc5372a9e5c2e3c2daf8d7982e2e4ce7a204bbbbbe140fbe1d16264ad0a2d4f800a438f6a161a0b8e01989e877c3c50029d94bcb67a2eb27feea4442b923afd153bb934509f3cdd06ebb1aa139f0e3bcf7476818678808233f7349ec789454e1f1419c1008f75ad6ed9b5a59facf4df9b888e007e0ec94ae976a69d95c781778ae195443a1c2f768cf0ab25dc47c6ec5b4e2d32af80154a382695e0abab69979b5bbd80205e38478cf0eb2758045935e909fbe4e9e5bd9be6ce74b71b9e505093d7bb2bd464602b8f7355f9a68e854043779d5bb696c52b57d14e3c25a06699c724d6e89bb17578a2c1f21db54d89364acb3a1f6e3952e10d78336b31f49b88dafd79677fc6910b929ce2e0be6b9d1ce6107ba580827b15ebcd5c6c6d0e31f17f9c8c224c762df79342d4293c3de0e6e6446743cde251d27a13cd38c54b6d38d5be52d9b4dbbf1751a9774f55cf36048f7ef09eec332dd769eab08cd828c7fc6c48b87cc9c3c88a77f0e7ece30a467ec18c841c7391219a6ddb269965ded3ae8a01fb96d62b7751228b9f8b8429bfbe9454d697c98544a36d89f80b2fbf8ea258d2d56201fca2deee060c88a936213628971407a51f75e6f643623e8033af520c4855c99642d43b269a09ec6bfc4aeee8bfc98890a668084c653c9c0096b2c8e802e73d13f0ab78093d96200d4333903fcfe2617708094da84d852454f39f9260b4c963e36c389782a81d9818becb98512cfbd2ff680c8aa7588cb92a4ca83472ae9e0169bc0c5534d247cdb72ce58d01f7afa9f0fdadb9c393b15495bd8209266923a930ebba5fded0bd6e54d5638f75920edec863ca14d48701ba93e171c1892ad25fb4c0bd09779bacb7add0d6951a1d4b2b711a6fb4822067eee633ce7c05ea85c584e88c5269e87f630994d6d3e8b65d7209706cbeeb536d562982aaf4b91dc2e50994106b0cd7c2cc157cf95c756f613d7c456e7269b0d5f5e791edad9a12e8bf765971e4d7022cb48b096229504b61276234c7651cc08b0b003ee78ddfe3fbe098966580fa52acc5368f15105d0be7bae023a080113e824b4560d0b2c72357b1f046569cc251b1256f69e6c79c7952bead7e2eec6bbc84c2022ac37b16bb07f3b027fe0d296fdc651aee718ee2883bbb2b87098235408ec734a719fdc56211df4d76f067e445a7b985596750b8a47ffa6899d6670553b4271c7f6ef2ef0f669b2b5f55c508163a1f79904ff1810812850c248988f198adf5c8fd737cdee30f778868e7fe35b01805c4d85b3a3790eaba17232a84f7b04026ab50e5cd96efb42fbb1f10cc0d6f975a93728353f492043cfe1c44a2d263e0a3fa8ddc5232cf41cd44da35cbc01208d82ca1c57133a6f3849ab6186e66528b9e437ff7e24957a1231687d631f7942dda7158bf4f88087da70a0651d70f0300b5f010a72372449196d6d92684986513718221d34a1ec82565155fe540533bceb0cbf49c7d98608150d6aff59d552e7a773a15332268d837d9a958d3c69bdd1f7fc8e7bd8d1470966f4a3be3f924364acae8741ff9d7db8770b4a17ed37696cfd38ec7b5a68b738c29ceaa236dfeb1f75c628826f1c5a5ec9c36124032de3e4d2f60a684b2de2502ba67849e6af5431455a3a087712bca947345d74a1170b4c6501b91d11bc1924f9ec3999aaf75282aaf9e6177c19973815202471b090cb61f43399d4875834b93cd9c2313448b30a3e170ec40f91fd162e56b92c2ca20bd40b0632bda50bbb493243b6f641c7106843828c0c0af76394fe8adcf4fa1f9e0cee6a028c8ea7c7d385cd35476b165bf553bc41b5f47a7c777c3d8eea65da45fd9b50c31ef79e3590c3d31ef4c8d7d1a5e90f3ce4c3ce137e13f160cbb87b88b753aa5c57c413b815fb5022e68ac2791208ce64c482036a9171f8e82d33d69c007a87203850dc1ee083d5901eb6ddb20c054366e1b2d4851927ad40b120ffa596761135f80f1e58845142fd4cec5c60658e864b3375b93a46934f5fc276f83a77651eec0803fbeb1b3d1d93f40f35e8692895451300123f2575df6c59ab6e12b54bda8a0b6b3f34df819b77cabfa2cb694b7d99187a507300afc334a20effe1da1a3873a23c16571fa4ef9d9f7ae11da9150e3c9a73a742054d22d6d81a174a11b342dd4b1847ac6306bb6fece08a866eee621550e605085f28a3b6df942a5f7cf28a62abfaa61f79053306d44e1838e0597b01d17d6af6dbfa78952e5ddd3f3eb11905ab480b467259a5ec156c1400faae37c1bc7a80ee378781b029cdb9ed61e314ebb38b00b906ccfa21aeb32aae40ea8f4d57df86c03cce6e09ad46e6044477f0886257096ac6375b259759584ef55ef508b89d543502264c0e5a61ac98e1faae549f693e18d619b0785d36e12aefd6c202afba2030706a8242564dd1473c158b59b3d29cd79ba223c27f09583becc9f3ad3bfff0599cc4c53cd1d1e313d28e982f036d8290e692b763d60510a73f1569208cb6609ee081a9aafe9866d650b99dbef77a64f21338b3ec1363fbd22e42c7cbc5b40003954a1011e4cf5c3a1455c45591a5d4b273d27186ed029a51e795f8d57b82c2069c77529160ad054fcba734e4f3b9a013cd3573fa29d393a704ebd5f17ca28ba60353ae229008ec7c57cb4a7718c751092b19c385dcf15f8243fafcbf8fbb0df0b38301d207885578a163b0b34c2a21f6c72eef2954323cd5a542e8c514ee5ed40e7dda9d6aecddb69cd1c2f257492ca50965ca938f4a176adae3122e92afeb8b151e1ddbda93bd9a143495d23d0a192d716e90c5b9295a74c652ec086409508512bbe58ac41f5f19d665f123abf7eb89955fcfff140d40a4b71ce74e042058ed72a814b5bd49f7c4aa339fe992425b2727ac3884f38fc1e6c777481b181247feb246d2c946f631f00e8a4189fbf1b0a182787f97e6b94d0edec63fe7363a1b03fd4e6aeda06b6e99321a1f930803bb9c832ec09a6969f25a91a53443daa3f46d1a986d65a2e72c2a2db7ff479616d4de43518f95535f270d0ff077cb2cd673bdb65fb15dcbd7705626aa1076b0fb864a097cf7e347b57fcae59d64d4b4ee766f2de8411b0842861b753efdba1dc5ad71b473582da5f5158281edd329c1230f2ff1065a99e6b95c1e7976446ad3f7eec62acb0650d9381e521db2659b4e3c46bca5341bf88bdfd78a012b279581953f1fe9356d03d0f646dca3a46b1be6b9e2fa57591dff686477468a6697b9b490873a5f4d93f14719a4984b2767364bbb2e3aacf9280f90ffbeb62623d424a415696fc780c7aae5f5aecb66bf54d9705b90b97f24a0e00960d08653bff7a6e1b9076be16e3939de1e13f47de4c6e671572787d2b16e46fe3188cd970a0bb8bb94b971c9af5f6f360152b19986d5605c7f40d2d41a5d7bc6055cc6592f73675419ad0cfef157b10f3ec08c68545fdae61838a532d8dd6d6a0db46df7f45264d43ded62f2fd8bd4b5b23c2ad24b815de4f176049ec7fd231de8cdc18c7718cd5c3227f92a4fdb54a1e6c9274cd23f153fa4d228013456f693bebdac9a5232da3f377c3e5e8557ed72dd019686f86aa5ae4ec7fb10a15a7243dae20de4382dbcc593f4959f93202a961986a8b4f00c9a16061bd9e1c31785cfbb5520736fd32bbd5b10b3add4b3e2b27df113d221098f8f947dec7ffac9c6bc82a2e47e79acb60820a54aec1b692377e2518eb5cb2bb23345f8535c61e8c92783de07d29d7e173877829a647ce8253f13a13f8c00dc4a7efb98c5a5a8aa0dc61dc6f83bf5705fa7c95f5b8ff7d24cfe391ec4a3b3d871a9c9f3f603c2c20c6122661bae0328ae57f72272df6fce81993cca24a6b8974c3c5322f28c6911abd04ad149631a6ff41c6d9fc30709b1793ee551268ff2d837ef1a12a7c65b3f20cceae6b12aba910491d8096ca7f4b159b9e282776bdf2c2a91ef5d3dce6af0b63d28ff7588b8e8c427393a854d371f0149ef04f4f80b50334cf1c0c46453f8332bf6dbbeda1d311899827d69ccb2b3feb4e2b866edd44cfe35c589a7dab8fc527cce0d93810270aa303893fc9e2dda6be5a8e80f298cf2ab816dfbd8efd9cb9e1854064005348b9819791c7a807b7ef7cc8d8c38f3a757769f243292dcadeae27df72c27aaf9167c76e80f4f66ffb2b8ee0e59ef04c39a275fed1b6d63dc9697e2dc8a3c8e499fb2a1fa4cb7638969b6f460ae064df0f87a0ec4bfba02a703745c7b0873023da5c4533670cdf30036f71d4584a57d83ec9e851e83d8ec9ba622d1d604b61590b56b08bea0178445be065621ce1dda3996e878d683f4f8218b95edaf74ea16e2d13d5c2d616ae867472d5bfbb1137618efc5c404394b713b5408ff6ed984e50f2ffac52ce00d3db7b9ca7b8e332d5fc2adf74d3c62c9ab5f9ce6576d06978c0d6e1231618aebcc5e2f008950035eabffaa14922d4496640ca5c1771cffbdd83fb9b00baecc9eea58418d65a47fcb71e613a4ba70b7e34e21160c9b093bb042973d235ff7014802d52b635ad944723b1a0213fcfeea58b99808e6442014bd77c8e98d0e9dc920c387a3d302db495ae09a35537a498873bebf90f52ae80b1af4916708bf54781974b9632265f3ac28242e1baf1e457325fef84f3155a16e56335fa3cb7cbcaeca0435dad0d3bf45243fd5553444e41e6281e9f45c4167342a971839ae0c80f03e5dfde3bbf38d835ad7ec08e54099c3cfa5807b461b7a35a64ab644157bd8f9ba2f8083f42e24050ceb45d9b80ad967707329f6da2bd0795c938801858d337d9e6ea73e572b5da770300fda7921b5050cfef101f64616d1231fe82a62ea2dfbeb485b58e9babcb6f13975f706de75ac3d32a1376c35cfc55cff4905b2f27edcc6ae3d38bdb3759198c3ff13ee4d7b379d864741c325f51a529b80862182b634c7a4c8dc349039a0c6b8fb2219a63a718cf84301449641475694f01a1118be1b8f03b1815a169f3bc165800b41e007ca699f333db727b5d39741ffc72940c68491eb9ff4576db51e216ca85c55b7aa197a4a44d15e4f042af3e7a52402f97d41f0576de5628e27e995ab5763ec563d6ab6feb310620a6c2825e99152e8cd4d9769fc4e4142d77faf05d88718b693a5ab43af385955332ed00428d169f70d16d7cfbef8a07557df63ebf407b8ff53434a62b4cc10d84d40acbae38969362257a47e20ccf2059f207b66a0095b6daf6bf0ead221a5ac08830c9adb75446e2a5ba206f50bd716a4c8183833c0dd2d5e601f627b2a48d6f3fae56f84616584c818e29eb39270f254e19477d9bc6c5e928db50ae89d25b7a4574e7441be685b5b1d22bae286ca8f34275d1df8fb54da45732aad6b1a6a80767bb8ee821d259777bfe05bbdecb27fa8f23df7095d0901023b086fd20300e23199302fa4f32874f8c050dcb4ef74f94522d729ca9b1d7d81cb8250dee6d752d4dc900dceaabc4bd2c4b9dd53e7118a965e7198a4b9e60261e6c23cdc06f73e34407f598f0de4c6d8e4eeb569ca6bc93777db09d67a55b3570e0cb0087ef7005e8ec344c418f2ecae3ffd99ab179a8d57a73dee4490fc56c69631646686084740450019797bf76287fe9997a0bc4aeaf75ad607f80cafefc5a444f4ca673054eac386c40febd049308ee033f4ff49232b4f17fe045151eb922bee85a739476859f4dd50bbe4a874e9a67412379b6994fa0de8e9514fd099504cf057c884a733fcc46d3f5aa9663486267006ce5b06e8d6d266098d49da138e4f420fd2d851affa7837fbce684b256c4fc99ec2a164288fd7ab95d823188f9ec7a1876e6837b9589c9b8fec2b64661b696abfdadea61ae461ca81ab3480fe53b6123e95b9c41dfd3ab260f61b683e07ef7e7436ff8421dba1eb5b95c0e86d2022b81dcee176cbd242c006a8004401a406cd39db6d1c7f35ed64dc44cc382880b1d188e50a3f9eac2715188d5a0139788ced450434b589b31f6ceb212d0a379568fb260af5cdabc3f35ec2ed6c4e1dd722affc23cfac43ba344962326eb0ef5eba7cb1745f88c66c3ea4e20495c9ccfc801bdb16fbcdac6f414c80b07fc471771b2bc4b38226909513d38432806fb43c789cde07559d41f4d46b010b64b61e520c3fe8c7685b17ea2b9350d180b85c5cd7b31557ee56df21493608a53ba98f6b6fdd2b7746e2ec04650375e8f00fb68a3829cb0ca5c3c88b987d4d11cd6737761b56c2e97258d5a3e549453b17b7c2b37385db6fb8008a026209b327e7d8a3dbe7d294c6026e38a914fd4aff1b16e545d5ca21c7dba39d030f358d5e44463e1edf42bf68af698c6cb05ce6a7dff5d55f0ec3759d80d972f38731cc060532f3007be3716e0fd8464828b625132516bfa591eddb5310a4da9a9fbda972350c9ee4dc3b8ffff38426851714ac5f0238c0fe5b509156d9e05fa9f39e0f5da381b83e1fbbe492be74cd785cbfff01bfad581a44dc8679b637d25221ccf44b445e3cc4228fae7cdb62055125c25770417cea456aa37291c11905062be0392616116a2297d5be3c13612841b3846455e8744e0c3f3f0f2cdf458057e4d7a87f0deb1e696766789153623d61a4f5567815d50828979aece8d6fdbf475d7a4759ab795cfa137de0022c29470df2f97ec35c90c9d6ef28d92912fac4204a63e208c93f04f29420bcce51012274dce13a27ddf5e92d36f30873d361c99ff886b1c69a7016aaae28a197c73ac7df67c2a7a77f9a30256c455d7b2903bfbf656e478d2b41dea737bba0e7c92a8b96d0a2323c8905078f7488786ddbe26d4b10c0fd14aeb0b96084314d7898550d976a5b202e3a7623d69178cc39d790e2cc906b18b9e0db9bffbeaabef39defc1df0f497f709571038ea9d80ba6a3e67b907232784b25451eefb621b3a6e2d8b28c3c75ba523c2def20ce4a3d568a9ed52dde95c946711b662d40b4ae74a814cfb2d37a6872ab39be1912629c12401995a27209f28517ff802723de9858733b7221ba2258130b4eb1018752197ce68457ee2a873584ced78cf3c09f6dabe37641d417d2c704e003f8919cfbead02db887f5adc42bdc67f8f6f8f6ccf2b0345a43eb5ac98fb8624d10eb7e444ffc38ca27db4a46d9fbf9ad9a4507320a23439b2c8b6dbd6a8b50bf49be1811851a83a08c8a9609593f7298e98ca7dfa3beccaa41ba61c639b127f9b394fddffc6b404109fc1e3e5549bedb62595b53ca315c4664040a6139dd802134ecc5104734e5759b07e2742e42860fb608e17f1ee2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"52384fc8282f908f1b8f999f4b9b66e3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
