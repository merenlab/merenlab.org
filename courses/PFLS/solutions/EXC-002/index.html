<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Solution for EXC-002</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #217573;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Solution for EXC-002</p>
                        <p>You shall not pass! Well, unless you have the password. Then you pass .. or <a href="/courses/PFLS/#exc-002">go back to where you came from</a>.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="SHOW ME" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ac06a9991e2ac404cef2f7c539c0c8b96938da73acc34fc616af6f825167dacba8ddecee61d8b214719bcbd0db67a27cbc4924a0586c1aca636ede1f9e556161afa1415194b8febe18eabb64e6b88f71f41645bfcb485235ec692541e3773650ee352ff1b48fcef995499be439285889738b41b307efcb369e81b4235198a691195e47d25eb7498877a62934d5bfa8284fc864ae34ba99b44563821d4cdd0849e41f67255bf25f3a7c28d23fb666fc62981e93724a6ffb1d9a7fe3ee004c3e7f13f304de06ac04d75e80817ba0e62c6ef4016271aa9b0a6854273a409fc673a325bf11cd425451c3e89f0b1b4070fb481904979f0b0c599108979a371c231f2f1bd3bccc40b8e4b49d32d2d6acac9bde973b41ad002fe7d48650fcd1d6c46e7b338eaede647856fe70af0037d94eb5a1a2ad84174cc673ffa0e5bae92c27f007ad8b2dd0ec8f3a38076b7120a47ccdd8f76b147d8f7baa7fc7e66677bb3d497944d2703ae80902df838291665665476fa87396b4b9328d97d3ee3d9052acb166f01cc9416e428e25c595567d7614fea0565d71f2181285e55ec658e13832deb1fa360ac5d333f6df81448e301d9c8751d68d080e56cd31e38c69ae076643cf36783ea0062372d02abad31d512d18e306b85d5b022014c9d0cb7ee724c276b942d45dd9a53402f1ada123a79fd43821a10451a56557bb161064f2333835e7136bad2a989c9013794ae013bfca2315e69e70acc34f663e0e33a75186d488e2c8268fec6e5c9d4911697827e43b9630a51d4c13ce8f7fc0965e062826075a9c0f0214ce46ff2e62db2b8602898e6b870279b4e6f7fd1db658b8b0b9cde9935d29801bd030fcfc2f8ab654bc4d531216ec69655c63148434901d4796b6263e1093815ebd98d3d8f6510ee0a5faf4d7edf623e5a6b97fe189d706550a2f42c231b820761024a0d397eacf5267fb31e23ab9a84ced15f8243af2e490cbf5173328ceadb917e9d5a6bacfefec3de008b80ae91987ecd5d23572e4d8673d014294b1e933e28c544dbe509f9dd244173ef199f1839108c4c12376803f26b4d5b7000933e60b9e53c89e3078097a152ff254ef8d9b81a13ba9854ae5cd69298b5e3e4cd1214d886c813de0c9925ef89432f9b18992ee0ca9521df8899c428f6f2453c36c44ae8a5b978cd2bcf4b5b2ce6fdea4fedfb4fb44a30affc64f2dabb588644fae22bd7af24f823d8fee6f687cc0f0c89d054fc4075598ff8ba9d921a676da30cb1a4029c04c13fcccd3dc3ff28362a8ff5628dfa12cd3a10ead568a04faad5a44995ebd7f466dc7ac1bbb081d6cf1d75b892f0b2e1c6054eff171e52abedefa9dd84491fe3fdfb1612575b50a1d64735c49e6e2e7ebf2ebbc6a9b2d82c4730ace0bd907213c40470ea81b6698e11df04f39ac05b024d446b74193149582d7f14e83e1b3e675fa901080be29ad7f82d02342908b9d81cc2357cd15b54f869470ea4463b0257eab3a3984dd335cf81193f440c9a8560e905fdbd10a4c76b49b392a80b3318a3bc550abb0aacc7866a355273f0a23142f5abd533ef533d3a3c1b2d6dea3d8922c3788f79482042dd2e95ebdbc09d4e9ee94537543534f35dc79c91095ae4a5c086b88603ba8cc3cdc2400fbde5f8cbb3e7c4fa4f79677db265b768a8138db9668ed28a78b1fbd74abbe1f6da556785aba72c293898d368b584bc8106d9d9e4798ad279a1542ecf1007563f9481305f450cfe9e33cd24ab2db7e3293fb3bbce9db15201435a9bc6c1a4376da69f599da14a05cbf82bac2e92233bb73a8a4f064e9ea399968b0a4e30b5b57743e4d46e29a8e3d0d2d94e8563b3211324a926b27aebaea064b8bc2874983afe8b4928b7b200cdf1321666180ebecaec9bf4c6dd1925cfbabb577d246e39968134cdb4298b81241c03f5169648ec243476ac002d482c8d56d9454ac42e2ef54bc1e611b7d07da7377727179b9221d7c7f9463fc5ff22a34362cd4886e9272948120d5bd054f724d03d7fce81469d846e0a0e82923d66bb353d1cd1dec4742a4e5d4e4a2033345f9851f8e8572b91d77b1788e9fddeff2ab656112ec1c10344bb9d99886ee2d63632fdd9d8029d715d914e694cbc378bc7150e2ddf2737ab9394fb30ce624ec59c66a23d0ed1f2b09d179d483a6eafd620899efdeece5c1917beab793eea7f5c8e882b110ba3575c284b205dbe5ebab8c5200091949a62a315607514e751ab46bcec74e2cd0dfdc0697f26371071aac6cc075426e29db957503af37bddb7f00817ba4cb09edcfe3277ee653ded274db3395513a3f01c67a719431b45ac63a3076977c3d66634f835e1a620608abcd529ffc0583024f25235e552ae4d49cd0b8ca0a503f71338b55b3c16debe24e8584b7013241c15a7e08f0da836ac151362d57dc46dc65885958c1fb122688b1ccd73634eb15203407de1e5db19a6a030eb6441d7ae4096c7b2f15f7d5170771b6978e768801a25e375ea1e194333a50749ad48f2b2209c9c0a343b84027a4c15c4be3f986a3d540a92ec3505cffe66e03a9246552142d049ddb8b1d1beb4524224cdc717a06c83589c4d59999c27069473bc4e19f5c63186214526d0af530f1a4b8c48089314092085d7588aca6cfaec932570df2b4989fea84ed830d7a70586b1cd435471296fdd652380ee2009d9134d0cc7bf676cadbaf6c4115c0e6e72689773f13e0905ef99355e0d05e9f95e0f5c0e3bbcd585bdb2011c97a0fe07669549f9de4a05bd4643f1d0445ead4aa3e2eecc542f8a854530bfb99a4ea19a41bb2dbb9661a59a303621f35140048182e012ac93737af0dbc76bef1777aa1855255e3aa35df0f6ceb5e859c60f0dcc21615efaf8c8f80999bb7b00c4ee8615eefd1f70d151633c50210bcb349be308d4a18029e3ae20ebe66294ba248b6de1481aa2aaba367cc894447dfaf68aaaa8cf6ef56182843b957c8c84a9029ffc2edfc3bcb8c0db29bdc2cdcb4b825dfd8353f98dd66d8b91e0516041f4b66160024b190f290bd2e24ece417cfb6a86d8728e3432be10f83e9f5098fb3d605926303093cbf3cbb4c3d25c266bfe4d23cd7911903c85c43d5449f89db317462db42073731992a1465fb298a59832866954ae17b900ef132ff6bd4734514caaa85fee31f2998dd093843304afdf72becea60648a7fcd31dda05feab4d80ed5deb5bf86bdfe4e1ebd3b7f202278b60d4586e4cb667b0f12609135733c52e207a9c13a65adde23bb071823c9dfa62ac9a4f85cc5bc2679c14c88d9e4fb56cb325ac8441181adb37b07ef2230dc8712a0976fa1031cbc7daf1e68f2eec9fc720af674d1cddb01293ef3766e6af8cf3bc9ceac0d6fce0f83871be9e6f8d38c53d8af6448ea07fd84c1f1fdc38e6b9a8c7c09fffdc55e29b8cf6249eeccbec6364b7c36794ad1e9b8ce5af169806554b350af1af2e55a8f8cbd02493a48683f52a375f9a5d98f22c6880efe72049c70f6d6294d4c48a471060299b925d952af6962322cdd6e4e8b62e1805fbd902b51a6c4e456c03100dce5217ac21a7b11e3e71b305fa3ed57b99b2af1eaaaaea6bb44894d74ac456d00f7c19cbeb4ffaba66ca0a4a39322c34972c7bae8ba5305aebcd7f30408b8a42357f821e1ea935944f6edc761744c74496bbdd44f327a861fc8c67e1f68f4d7fc3b243f5bb2cf40cbfab4252109a70c89ee1363436ffb27f1215d98a82732f5fb59f1013dc00787030f73292d1689d9af9be603c0daf57cb2f838236d605cdfae44806c77b8965a7ec3d2b1134a0c69420b80b150f5421ee17ecd1149629555c1e5bb7544bce2e1c56f620b1b83af12af63bbc1f47e170afa2cfebee8f60e45e7e6213f157515180ae32820a49067739aaa8b189d7611c4e9a956021b0ac84b4091fe5c91eca4c8d069370f3eb2369747ef9eeae2e2ad966653aac864f5967866a8c4d7dbe7bb8e4fe7da79b755d507bf70fc80e2f5c136037d198d94ef3c1b364f601547848a197a7d56d1b6494f361a931e52a99ec6e4089d01e6c0cd4a2011e10697a2e6ab9d9275b0dcfcae405c7c8df8ffb9aa467b9479162984d667b7b0d33c37ce6e401d1c7ec57a72382e39e22ec9329a83c15d5ab670a5979436afbe4d403fcb3bc731cd659454fe4786b0c21c8adbdf75eba5415f09cf1c35938d2199b04ac460a92024c237c73f33ebff217e9f93bef2654e63f16b3b0a89316e17b6bc06ffde37f62bce10926c8b4921d5d52cbabdc030d07bba77e85b9edc3db718968eea25583fe39a74db5f8317ade66e8274679bd963a629f24818c5a23ffe17ab79301fb41cbb9762bd25f58f877e34cba41ba66c174e145cd728a80a8aa63c475473602e8dbd50baf51bfd34dccbe253e06d4eabe132bc61caa842cfed75e79d212d55d0bd5ceeedfe13174128a951be64cf3f8046ee75240de9b70a12e1c1f65e9f1456fb66212e9f2d0429fe00941da4fb6e2292e8bca8f45967f65992af789a1b27c717cfa989b0561e11396328db0b7c38963e8021e1c82ef1be46b608b1fa8a641c789fa2de7251017680c52469c5b3e85167d5902d1931594768e17d44aba7fb82efef8f10dfdb1d2c265c312e4b2ac6a1fe8d5efe87752598af0366b8091cfbf3c3f524e837bf1b9cf56d3c04bd5bdc615b3a396b05ad4e81f6a0871a07055896c98c7e0e766d026c6b10e560f3b55b6fc9ce702fa3813ff56ff03399509e8b345c90efd2776d8c9e728d6c9df67aa0d571999ff93833bb72621b47e14c09023e6874b2fbee394a9701e6feb3546aa86b04305a12403b9a43a94b4a2e3bec1241076178ce5decdc097246bf3ff39647be3f1529c7a9a941e45e8b91dd78153d4bb29c72c956b95b0a63aa5daac91fb0f40540e7074f6359d91b985814c44ad95d3583eed6b7a1680ed0464e162897b2761816f0ed89e0e695189790e1f66916bb58730dfbc5f71ababc1017f16fd6ae686cfcbce0e20783f11c8fbf59e6b89b68916ce06b17ef3cc2155c897f885bcbdd4faaf51c6bea5548ae26f248f6accf37187f66ec82e9c81bf9af4bce079e7b478ed7e27a2609f19876f607696cc4fd14efac8b00d58728aa860383b450dbd5cbb402555e74ed56167227604f284e9016bfbb661e33d8d93e03fde9092a74a3e360c9dcdb72816584e1c61e252000050cf6e38d50e36dabbb8848ced58fee7a9ad5b22021d429ad9d967203b0e684c52b0fecbbee274c8009b35a9c3f7f99beacf8083531eb721062506703db025e14616652383270285796e32ade36894537bd13f2a93a72b78eee3a432da1e349ca3d064155af953e88fbdc97edc04b4d6bb6b4a2dfeaf8355cc0eed23e3c96e3cac4bf44703399ad0b45f59b29e167598239e233b0245fa5196960d1db6dab67f5377ba9b9f2261b37ab611f126ce95c8ccef4cff82476fec93929b5cb64dab55acbc8c61ee392df29d68feb8e9edceb15ca601b5ec86b1f308b67f98c799e17a6501e1c642546ea014d447d5c57b3b75a77488ae049528c4937fdb8b2481b65a4d7d2cc729acd371e1d09bca198435c04ff91d8cbad5fbd552a5ba6cdfcaa3e7521be7e52aebf03e499df4d38feaa6a6dad4012fc1a1693f6085d25c7c8c973a6797c2312b1ec59e1feb6cc8c6c9ef14a1595420931712da47f222607fbacfc0b2841ef8c5c51db2a91d1399a7a308d966fb256c7a043974bf6cd726f19a348d00cd0b72ba9152d830ee0d2c9b1dc929a7b27d0247268c86fe23bbb9fbdb91f1aadb7bd6215ea6177759ba6ed5f99c254e84b5f4d6169f22175f502b6ff66342362943a6d318a88eb9130fd765cc946ec9156b2904e4ba28ddd18c7376c922c708da295bc5a590ddf6612cf3f756326fbfc0b5ce7d5406949b4483f750166661618b9f7435c7a089c28bd8195d83231a4e6d0289a1654ef9fb5a086b9fa844df3ca987564bf17f103d81a20e971611658a71b96df3563c8c6b02ffa575717552715670592568ce786ee9f4e2c08771be55101cd62cf428fe68663ac69e43f48093b2e78d0cdec42d34db6f64ba5c66d1d15afaabbe60575fd8dec5d8a8cd76697d7dbd26028adb23b88323c24f7e0a0a5aef56bf66cf8333d304df299b6249a516803631db633196662c18d24d1beb7bbb4a01685258c57d622ccfccaf6b2f59073ea13d86d802731ca9620563b302e0281a6849c63a54f8eaf1f63994c46ea04fcc4a59d27191527ddede40597aa4084f6abb7057a6adab154e5baedf36b60f31d44ce2a2a80bd41f202124c0cfcc6b12cf22322a7f8f2dce201707adb4021c0d7f6eaaecdf5b601ccafb22086317a0a7112313b1b8198ef043faa161f666c7b5b8cb4419292561111d2695c0acf444c0ab025d028ef72de4188f909b50335a78bbafe9876b6dbf4146a8f9aaf1aa3996349b3477b02d1a6be2fa399e252902ed14f72d10971efbba06bced3907299601b226e3af7342a5f42bbbdba968e3054999679b5d06c678806555388290687c3745e206cbf6ad0dd1d08e2843a961f1878dd52433621d74cad943857e4d0bdcb6eab24b29bae1e3e17d23737a141bc5e868cbb58eac7ac0e3157507764d952d281dc5336055af76ec275b4fce3a93bf22b34f180376f1b05d54f076df02aee63d4dfb260da7726000de71669720acc056d34800f7336bbd2b76b81ecdea363e9bfd1a349b3d7d1e85840d3657793d372113ee84b1024eed158463fa24a5b0e604ec7be76661feaf5027c52e7a90ef413dcfdde05a6f129440175ab2e2fbb203e05511a63a5ada7e638362ccb97398613644ca5021bf251623240a9826edb179a85eedb2453b57e8e468bf3de981804bdc0f1692512a31b1b4b245ca168829ac5f5118645d7a7c0364a5c27c16226856cb958e70bac2b6039d5704ea555f4b74e72dccb2bfaef27dd925c584eaa37324ef22f71defb9df5605485214a6fddad73749cca1cdcf6e1d0b84edf30a9752903c534475c39f7aa38e97cb8999a09e588d8e28c44439f8c993a8fac446cea065448338b437298b890389fe1068d4f6af9bb725e637a896c85633ce7c85c0cbcc405ee9b4c4c0bdc2c3594d2df14add04b8b3e8599f4bf1e467efabb81778c2d34eca7329ebce2b6135da24098085e4db68ce0cc3ceac61ac1311b7ad7490bff8a004a45b996b94937f0a8229ddf7d836164134b2f3b30c43228c5594088a2843e2506bbfc56f3c171591779cb24f1aa33a31d235b1f94a72be48382c7566ae1923e883a17e592513cc3f002613792c225a6cb2ca3c0b1ea6e11cace52e782d42e6265900b65b450d976d61aab6a21e30a5814d18f16a915bb31b5fb90955592dacae17fa3a4e007e53ebea1921e12a67f0b5d16ef80640e45378f6bd5d65bc85943d9d790ad740ef6edaf35c759d325d6562c2075e90a8bc08b7d09e294aa75124ce63e92d0a3c0e94caeb5980c76a752982f25d2f72759075a6b2a182dbf7e5b76956c2e9516d0909f032739c2001c19132fd520aaccfee11d6074198f0530666714be25ab32327c1a2e8e5724a8eb3dfc2aed9f7e76fedfcac66df8cc0f25157668345729d05457ccbd9b72903b0ad56f1b8a6f92eeb161b20cbb0e68c85ef732f4524ee75f8f28bf62742fea5da788471070ec71f608abcbe20dd83b81d8d36a1fc8f85df018cc0c54541be2003078ade4ad5b8427a02afcf598b1a93773574672e66854cbe1cb91848791909430b010735a516d8955b2f7f89d568342dd3338286dc3ab8e97fce910ec7e4319f129a008e114bd2624318ccf1b9ff8b89ba32a8cfc846ff630f3e012a367baf74c87a7c7a919742555fdd1d41367827edf94c69e1072c65e73ae37e31d6ed75a9153d994b430b1b908d6c9166e0aa43e0533021470e2fe50126521dd1cbed5fcfc8eee3f28dc065aec1690e1fa661be2cad6c7aa97d5f504d9ef1a9343a086f519a9f43f478f33abfb022b1677c73079df3af1c382208ce37b8681a82aafb18fc6b9ca9703f629d739c88735fc1c9e633011e04831bf7062799cba4fd68451dfca3ea9fa5913484e54349fd9010c70fc3e41322673c43d063dec73d234bc97e6be9ac5017988f587f8b89ec6ad343381a70dcb8c05cb5d06b591a2fbce44374e68526f142bcc07e9326eb964683ac25190683cde3dcf5074e95eda29a3bbb9d6cfc7c0441d8b956e5e90d8148158cc7a50839238a2c6431dc8e652dfd54ce5550ce27c11914f72de579070f8f55a66a6c5a5b926e4ef5d4da69ad53e6f0e00b1214172da38d45a9091107f412f27f3aad092fad12b16b01630e97ed2a66ff6e3199af451252d776e4f77cfe4db157ff537b391807406d67e5c22746eb35e4fcb20095b087eb29547637a4b45e174bf52755c4e1ac56d2da02e3ecf4fdda0c3add42034ce22aee1ccbe0a08555a93ba6a33280a60060a1be2bf78555d4f1da81fb2c3f198239d071dc3ee332205bcb8ff4956252f726d90ccbb4384ca951fa40c4bcff3edb900fb55886a2c0416849d6f309a5308001a3433f30f48aef70958c61c6e9e4271348eff3167be829493398da42f14721e2f0db1d1b414958ebfce63825f3040fdf2298e10d8b469208f783dde144677613d14f44aff597e341f8fa39a3afd5548c5a9ad399c7f51f6bc722da00abed725742f55f47f2553624d856ab017aebbeea58377c32f53b1dc60120fbc2e13a723596b01ed94a3ae989cd16e4a71a3deaaec8a7090230ef33458d35a55bde4ff8086e95e06159d16d780b8998d67ca81a24c6656f04fe087dbf6a7aabd0209fe7bbae214a0eec25d452ec3106dc648cfb388929953ce2c0bc089ac963122ddeb1d0c64c08c48954e12a60bee9ce87b5fdbf28286c51499ac155a66f8b6339643a41c4669916f5a61429755db8893558bf0075c72438d9974f1b6598523c11636dab3bdaafeb1d0fdc019bc5b4059d92f28e641796f14a0c5bcb1383b2e93ed3ad6dd2d3a74660b7086086cf0a7f0f1d5d99cafc936079e708410d6188d94ca37217fff07b6290354b96130ef08e4c808fb68e85b7932f030dda79e29698231e3f9502c5252aa04b5d8ccd85dbeb3e6f22c239be87ff90ccfb6a64d061a174a07eab2c5abc0e2fdb95486201622f1575a27323d2ca6a0e2032ab544cb1bbcb6ea001525e247ec9f3cdfd79dfd010fded2182f2618bfa65433d564cd6a5717d976d283b184096b0e3e18e937f3fd47602c93a9bd8734770da4bbc7cbbadc7647f070f0a66f290b6d8155381a76b3aebd1a69f38f7c2de04b70bb8eddb090580ca451374493f81dc94555f944670c90dc6ad96c2675a678698da9552a9b17a4d5d5f2652693f488dc934e0187263d72c22686319b092bfa4b6993629022273281087bd0d6d13645cfad32c1dd746620506e805d51848cc5b38586a4a60206862628516b085105095a8c51ac558ed33bad350c447091ed756a99f1c7ac302baeb1d740aee6a7d5380b5146262c6132e25bac3fe50be09bcb419f7dff2d2792b94cbe9bff92499fbff0aaba814ebe77cf355245ee06d1d7b0c73303375bfc944be59daa8e73e6788ad5f18b26b8742d871fa0178edc8ecad87b1184d4539bfe69e1835f0b2c3df19207e29ff844ca8f6ab92a184b98d17521c49d3fa85c64ace52a47c3aea34c421b2698b0cbd1cf23f38e966a2f831014bd65f2a756af313106556be4d1ec739b607d25d10fe59fae52c8ab6d237381257c20585ed931aec8a1b2d55817cbc4cc63cbbe2027273cfde6a2015c3937eec334934a01157b50149980769d9f392fb1b519c6fd4cac7a3dad84f166c37827b8baeed3263ff0b7938f225e354cc9ecf49b74545f75ea8b8820debed7a382b08539f6d0f04d565e95cfad91da7c06a6bf5220d9a5b1c8cc864948b76cea184993c88f4a4ee084a2988cd3b48350f4d8b9b0ff1d00e22c2c4bcfc7262ac7e5ee1ba27f85b540af048dddc2fc57b10b379a1555efa6264ea196b4dd80a6a4a4dce654c6ee53ee72913f0b390f2876b6388c6f1ad65116effb55d525b9660d24d0d5a33654d2701529f109ce32382078625fc7b7e2ea95c9daa84dc205af6bfb44b90a02ea312108cb725ed68e71c342a0c1d34090f33a58d88d9752572d890603b2ecd2e138ad66142c40a330eb8c56d1db486f3bc762a99124a73fc48152dd8d391758a8e787a616cb50e493f303de4739c08c33d7adadea734ab70233c725d6020199422d189e47dcba42453d2a68ab75b6c6491f4ca70c9db29899744a450f5b15a5aa6984ae6a277863cd20d07a0523f3b3e41a657542121371ec0002664ac9e1554a368c91217d3f9a03ae5d919ddf1eda388f397047c22d1b324af3b1e8c2b136ad0e1d5373d3f2f0c2ec307c68888356ca98e44968634af7be54de0de6c4f52ec9506aaa6ee6c9152e4b0b4c0e64f56efe7cb80cf05e3dc4142d38f1000cdf071e16735be8a99d28420d5ac91eb09190f32a7c5721fe44e6c38480f01b9b28f9e6fe01c6a5fb03866e7ff09073326ef5d279d78e137e726a95a80667a14bd115c1fb4ec8b1662f480db6c1a6cb18bef009f135b6e125c03744c02d7ca2b50b411233e04a9ea6d23acd64d17102d0a18f8c37153c7634cfc637a265f24212a68a547afd5b1d6d2ebc8fbd19dc42279bfa37bec8cbffcb426c78ccb9a49519cb8e1294995f5220c256699d4e747c4153fe5731e3e88de557378425632f8102019743350ce9a1f21da299fa017523c24dc4a60175daf23e33a817653576742ccd53cca535745a6aeba3958167898c47e4062ffa55d7831c7fb0620e7b76c408ca52e6942c1a1a875810497a6d8b4ad38f282c53a33a6ed0cf171177c30213228bd89374663a77eff572378584a00e02b14b9c70cb84afe5ece9548037eee62782be29f5e3968869c863d34379e46d290ef4a788866c44c7d04055d799bfb91bdcec2937f629fa63248fccc650bab78672a5f613d5f0df4553f1a23b942ae210171245396af2725eada2f8e1f742b8294097142e2032c52f1248a13044ab2194f73c0a7a46d6b27c579a53c073709edcbb4cbd317823d06d4347a055edf49d7c71c7f53b22ef74989bd0d10136821be915a9f841c6191275758fd8ecee00c4639819c055e81c62e98a7207e8cf9dd4f0bc2027e1e72cb1a838de71839b1767d146069c853955b1215f5dba8d746b9edd74e53920ce92cab30f3c08a00655f98978da724008de455da6d545278b1961beff654d9998e9b6512803a4adf60f7ea97b2fdcf7cf294e3e27282e5da4cc3e684022d44c4c7fe352c26d3b1a4f63f4f6c89624666799fd72b3371d5849e5f84931e880bd05d2ad5da62618b65565b92177998a3a5cc0339a0118a41e609885d1dc71bb0aea89232c1dd705f21e99707c882db24cca3aef11b30be6b2e05a230ccde9242908576eddcbd8eb87d7b16d3ddc399d198aa3dff81a9a8f3a0bf0c13fe54769050c3fdecc6a1eb9786b3fc01cf86a8bc6ebbc3320845e3eec2986261b958edec9a3a8bf2d4d091727ad61e65efd23ac936e09e3bd0dcc93f9c0c707250d06857310a26270cb40e1176f5aa2e2a1c9bbcf3c66fecc1514d100790d5167895e08d6b92370743aa78aa37cd6ef1e68fa51be0bf28af56296aa681c1a94e729cbb5e4ee84f8cfc12d2d317a94d405d2f50cbf6ad52a8595f8fa40d45d1fdda2bb37db57019965bd64bd7f45afda6b7953f44c008eb4c5e961331caee38f598eef40be839affdcc72b3a0b93ba0ad36b33e899fb61d905b08589b8c78145007f62d16b03ea29f74041e4b55695ef8257fce125361b6d8cca0bf3d7327f87c1c2d730a2992042f8b2808794995271ddae99f5b4240d4fc704156b3eadfd3331c70ef3a408846725f3b8660d96b09d473ea83ba486f8a7c395e42bd9451768a39910398c356279c1d8e35b7af51287f4d3642dfa5b0cb6b21ab368759ff1aed3ba317e8b89473148895aef992b8001e9d4a52785f9c3d3fbd24cd633657035ccfba8ffc75221e8d8cead4ce6b18b368011c703fb645ee260935c4c7b1aebdd3f9a8b10c5bcd425ca8282404f58d92efd9e32b1b39f303528513468a691b4018b5f80238090f299d9b39dfd7fe5399e21e2e5c609092b008d47c9723b080205bc5c3508dfbfbcb38892eff82dc067e95808f782a051afcb13f4882773d740772110b36b23f3870f780cb98c70dd7320462b72ccbbf81b7555972f13e7534acda0d3cba52d99f1872bce82c2ffc5e8144c0c7283ef50acd8ee6708d85810c740aec0747adbb3b7a7b3a2d07a5669000895cb5cfd2fd009ce2e0c41f352bae85dafd410a085cad1ae7ee0a068c36fd459188fafd46016d0af406796e5c35e0e8a0eab2eaf8d9bcc69e908170a0c5b8da4be089e5876cf189c26202d08f2576b5751e90779eb5b257563fa22a77304209a96ecbbbc1cb6fc09c13a50029a9dbc3950d099745f2311a0269030b9046af516733af2d22d56e1548510ad398e22aecf3d4046988c58b2904585a44f47c21aa59cf1f2fc0ade268ede52b80361c78c188296c84a321698f683e48f3e2c8042121db227310adfa5f949d0ddc6f0e259f613804d044a88c89a695c50b9d6ebee760403d40c518f014600970b6b9598802af25c8396222907f6f80394d0cb86f2b32a6ae623a6704f30e5c11310d3f883bbc177652c2787b8a0009060c7c0f92f87bc0a690e83ddd13d72eeac06875337be7f1026d55cc71781c1afdd223a80d5fe881dc41febb3307fd82217e853dda75d99050659fdb7d0d4be56594895e76c39e4622c3d904b921578b4c7d303f7ecfb924c01bd4a6bb170467271a9f7bb872969c1417f3b71c92264178d3f0d3ef1710a6f7801529ebe9d13e9b0f4fe2ea7c52405813a5f466fca3e5e0e5bbec6e9af41606433b4d0edd00231aa2e4d4de24f4c639258a5982a727e258329dfd954670735710f280fbcee39f12c7a7f4da487c3326e76430a7e10153404db31d3f62c4a622cd06b535fafdd40d50486ef695a264dfeefa36caddd7d5a620549d86c68d5a8db964b347123b0eff064cfbc79c401a6413923518851657f2bcec64b698c8680d414702aeda2d08a0efbf20e10baf634c8288e4d95fc464327ce043f75a62b691722ddf3eace7e36397225790d4d970482dab560be5185e6c55b2a1cede67685651aa3b2e49daebeb5a1903b48e70bd5e6f21ef3dc5b618b93e5a662339070388530e4dfc7eed267b72d631233d87c53b17760ff60a02a498e9af182addba9c05e8e0a99e9375a0ecf9f976fddf55eb08fdaa07b55483cca0f3474416e9934ff822d2da57c0b85ea53d40ee490eabf6c49bd71718819bb4ca4a2e4b77ca388867112c6b2236492639dd35e10a5b529a7e1398c8755a6e9a0dcc75ad3a9b46b10b374522060eb42fe4e83981ac9c7f81be4093f2c8632d9f697ba1061a5805085c62420be774c3a5ec12fa11c3c9a35c64355b744eca360c58e47e347a6bf92a7e7d4c8b0ee987847fb88f4a5113dfed97eb0869f1f2733737bbf260655a2b4cc7c789668f1d347f1620f78a2282c336786fee76d2a6511807920b932cde240921b620b62b23b0be53336d8e20d2a231ff62a25e01c7b788898985377a8ab5be3a59c1941f03b6acb7eb90cccd9907df74523c48d10ed1960163a888c2d23e4e3b372692c90e425699f2e2fe5671c94404d0e33da73506e483ca652891aa780ae59c057081ad9e74c15b9e587c215c4e04c3ecf085b2dea20d53253a64047a9b609b090409915eee27e38bd870ffb2d79ee2649cbb47c14fc067bc84b6388c6f382eba535ed0ab4447ebf930368b5f3542e686555fe5d16a511c3d4faae58e0ef577a1fda658163fd83c2efe58aab976939e4d1f84c2b37db116931fad75330488b08dae8c1e09e8ed0903d1595070afd11bf75fe108bc42c683c2c3288cbf21eec502f24761ed2baa35ce91d831e7e9f1075903d1275ab6b3fd00084c8cebf6b87b744f599632a1463c99cdd549743a6cb4f4a551795d6670f7286d287f74e5119d59b958abce9345989a2fb855edf1cb921b5dd5957f031174bf1df1aba362efb17dc660e74d74188a9729496846c489f217d5fdbc6657a01b7a2b04c45b28f9c141f8df28491cdfbf6a57c731d7b52ce7b028485741a6641b349d0692e7068f26655edd00d9b909548ba7ca92e274df556501528886e0be6699eab28245dcf5e605840456111fbd83de8e1d9c735d5e4f1d26df67e86c9da1bb52abbb87d09f4c20d6e5ad317d9869c0c71339304c9abed94241a6725149bd3c24b6d039db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"6d4a0191d8086ce1ffd97bdb1a87e16c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
