<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Solution for EXC-002</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #217573;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Solution for EXC-002</p>
                        <p>You shall not pass! Well, unless you have the password. Then you pass .. or <a href="/courses/PFLS/#exc-002">go back to where you came from</a>.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="SHOW ME" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb7fc8763522c644d4237eeb2d7cf3fb0b67f01eb3c4ec09d2178ad6aa9088dd9c78023d98fd81e52c5492e7e9d4d3852ecf3a145f4fdbe376bb2b23679afd11efa2dfc3ada1318b855556f029221718cc185417dc0b7b613af73ffe3f090e7e08442c8679daf3da85d5ba31281155ab7e140838ddd6f5c949cfb20a55b8a352e5e19b2c5a00074dc7250a9bb57bc23fb37a3369317251897428eff82ad3859536ccfcf12c5957694915341bef1b4bc9168e2b0263a36c271f3227e1d9f2e11c25cedd77b0442df3fd5b504c1ee24d592a43c01e7fa4f90dd400a571bdd970221a937ee589f3dae2b1c009d35b2a92e1c19689976da1ed51d669ab317c812eeb5caa04e66fdeeb36fd25fb7dd4f95162ef66f2807866f16209e7d40bb38109992df2785fc56cbcfd780c13f5d47b971db76b8c2f7c884f578cbd6c5477dfd26766ffc46956dc109eefea437c0fb0b67a2988ff33dd409973a64e2e105cf0f442b94df8420a6324bee58c3e3c9c94b3b46f82b1b85740a583dba7b55fcd21df11d620d79cff094a4cde2f6da4b8960565ecac8828b7c7f437f07699598d177c633a6c0091827e7f8071bda4622ed083b06d41cf23ef6eb0d6e49a513f76cf7f6151ce772dbed65a63133143a00911a3757d05a2c657697cc9ecf35e3e7bff81d3383daeb67ee8b458e19f0b6e92ce78af6c687f4833ca9efa9a57f4243f4a383be31e4b509994fc62ac26cc96914807b03359494cbf4db6bdcef96ccb7df65b4354579ca78980083162cab3af3470257a224bbe3b9af77ac1a12d4bcc40d9ba3b4f90af7b0177387a847d7fe6953f28b8c182d0da33e166722c355b76919dcd266d28a1a0629b1c963de961dcd7938afc63ecb1523e991205f702800a589be075ba7efbf2e3ed1bc3c68ea1b088b0eeac49634c8ff3f46b617459e05f879e9c77bf01fde24586f2038bbd80235e3670e7694b65f09b382f6ef12346a3dfbf78822b736b3e396ddb1d8ca872f04cce10c3bf3be0ded7e809eac8e7ba53b6fa43283fdb62b57de51e3de42a3ce8c203c25e78671d484499c14b2da00e34c9ea1cb67586ba34af1675b3dc81322a00f292053dc9134e991d3b0a191bbedf7dc7b2cc5e0aef86a143575f4454463f01af168b96a48f5fa9f1ea51c6fddf5ae2511087fe582f7164f28b19ae231b8b520fc5b2bcbdcf1e7b90161d06f5240c03953848ca0e69be406c69bdc2d1dd010c5a8ba311aeb6693bf0b8631bb3b2c855b751908b3ea4e7b512c066f3ff005bd63090835d5d977ba92e80bc5456944a4157bcbde79fdd5ee9cefe4ee5626d71e09d5cd50b2c0ce7f3d771eb9f522206eee8d3f371ff99e6e87a15e6ad008f68e7a2b80aa5f06eebb276253a15ee2c432972da5effcae829549ee78025a7a08495a80181f6eb806fffccbc3350cefc904e8689d96291ccf24c64362d5b09d209004fae6af80c90cbdd48725f1738984189313c5d237394e90fa14473eb46eb42a7609b447741f2c9e71032b05bb7706e9c63c2d75e1ed578a05fdd978cfd656ed1dd6043e349b6d3730bd5f0a4ce69dd619d00a1550d0a254075a1c710608c4a71434d5b0b0ee925073d529b46f607e324ee3f45772c29408823969cf5207c58f75b1feee4b0c27f56cf744da561b2a2a10eb88f247921f92a2fa6fd7f1b13bc87e8f97035f7290888cd7a97e2fabbf51ba593eeeb268ae3847766b319391e0aace268991fef9a74b5538e38469b6cb7618d44029b7ab6b77ecf507127f6a1670f142cb7dd59afc38c31b12ca0b946e11f5a1b5fde621a7c9b25d517f19970049d6f13637182def5418fc852c5132aa3b58373e24a93c1501cc9cacec75e9782ac2f8bd83df6d65dc9f4c9449730fabcdff937d24aea20e90f89c4036f99f4c36344dc14a2b66047e56bb744f8464e0fedec62737781e1b3042692e15fb3722ec30ccbcab0cdc5ee2df454b70233d375748991f3de3041431f904224060806af301d15a0d1f3919f2c0c6538451310babe85e6f9a8e9c91575e144f1a6496aec50d254b3eeede7773333f70ca6430a3c066d9d524491004a09f51236d3c3319a31720cae190f6ebf0f779a8dc12c0bc904c70bb3db3c622644757670cf7b2fef84adafc9efc9d1fa4617bafc60b844f20b748fd53edada6eab94e388c70c8461d480b1cf7f5a3e3b41b2629499c9d51d9df5359962541494da6754ef64b5b882cd4ec9a25ebc2b7c9391fce2a76fece95e81641682c348307b95f1a1d357313e8cb8e71f59c5824fc8a16f232c348992e8686f8616df2c3b976af2abb91ff9e370821bd4661a2defb5ad225923bc5ede4d3db972c641ddc7692845a5aa51e2070eee4af633c19eb9c6f09d40df939a249f806b85cc978e3cb749d205febad831de4909d06d35ae1e9369554e3b47d2824fd4672ebfb2debd1f5113d96a03448bd6596efdd55877e3f0abb89e7e01d2bb7174cbe835c654c1c842baf8dd8596244033fcb4fe5284808d1c4d0591062095f22fab16854f7845129a8824251f77f028b0e042a5f2e6b5a663baf8312a98fb6d72ac1bdb113689b863bba7703734f42eb8626653f8e00ce9fbe1c0d02c1139d0c6abb0d45f7323a0ffcfa6422b49e5ea9a335c88a23cf945335ceff80411b02b1f64b81925f8dc8a371a64ba2f68fe4ce443fb5b2d84dabea3513704cb939877277768114daee54818045b529784d50d9a3d116b03c795586db51030b7fc90669bba8a10cfcb713063cccb8afcfd661d674fb719dc20a225383ce6e4cb71e5d783438cba8f7bb2f0a033cc4e1d9dfa4a5d84d179650fa193b6c77a6aed91a99d954adce28fb4771115bea2a702efee18a21e466d7c6a3247b1bbd056980ced4145d65f1f3c833bab5f2fb9ca75df86bb41bc656cbe1d634476d8c1e2921c15353c5a38b9bdea3f34243fd2aa70b0e4d5319c681ac3504b19ee68fd1d3e939d1a66b71c5452232d942768725d0f9232000c6587a12810350e07316b3e67ac28496eb89585788fb328734fad855baee66e37b12b1e642b07546d4f90c8000c0961ea4ce1da16df0ec5952a728bf9d5a863b85f44056b0720b01f30d7f2e60dd2ead6bebbbde0c05db21b10adda60cec3b8c58dce5e5becde2217adfb12755c47ce575a0553202354496d1325b721da66dd536d61743129a909d46f3fd5a0ef67a5d640ac88ba51ba093dce256f8579f123512b3d321ff843dab0d261e544f5289e6b67754cdfde736c23e3aacac3304f4640e2a681b7f0bebccbc7dfe9655680552f16e64a1858569b4c38d45af7f28287989717b429f78abb1791f31bfbe612f4ebbb929f0bc5c68518f8f58e0338547db67faf0f08f48206dcced03f3bda5a37604dd64484ff17bd8d8f1abdeea4ce4737daef70b3e47743c3afaa1f3aeed371895107560e9c573900980fed63ea8037f154b870be1eb05fa34164fa56cd0cc7a52eb10db2f2be0342a7ef9fc1737196ba2889ca5889cce1ce4e758e086ef137c59f548ae41b2eb6d6c196f68f21209058ea28b15d36136f4148679a50535422b91fd124a9b291c4388879a3bae030c18d8f9bbf54d43a1f451c152a12c48fde0f0e82381221f010beec741fd115a161ad8257fcf30b2c7b48b8194fba43ce0b308e97937a5bce86a0da79e5a714555bb9fd09b46545f0ef3312c6f0dc1731c1d0d972dbdd2df174199b20a320bfca539aeaef08bd3aed8f159092d17ef0d5125f2996de0ad2d08fafe00224a3b320ec6cd4d5f8766661643acdc97df6652b256c70be198995bfcec147638025a5efd7d6bda9cffd2b5854b1413693aab3920bdaee74ce9f74a4fcd88836cfe7570211db2810190f82355d8394c958d95c051b67efc22c22e0605657da06a3108072e08e763058f0b340c777900e3f91d5b4edbe2942266df37c88ecd8d8e8c24fb58ee5014f7353da0f0ae321871ed1f51a2c181cc66aa51d691d3cb0dbb4037a0f9900e34c123562d7b62e857e27f1cd01ad7ec3824f404adfc399dcf574406af26aa29eabfbdeb3c354113e8cfd7bb165246985d189927770711ae7941c8d0ef249b4d8677c6ff20b71296f43ccbbe44d1dc22e42dd213af7ffb4ab81597681e754bfed3d6d9a068c9dcb4fed3ddaf52aab8df049643d843fd984d53a63f64c69b1b1b7f4ed6d9e9268586e49b6060b1262bd2f7697a46aebd8d203854f7d7c8f58c9ace4e413070b09dc38be9d4496565bba09cb1fc8389b9f57b6469e1b9e3f079b88e8b6bc2ad1b983f8cd9bc4621803964fc4ce12575c5846ed528a6a4cfbad7fd3eead24a8acc42d9437050d7d38a10c9ada7d6966b1ea6c893db108f24f525274d916a4148bbcab14c82b19114280062c3ae903041c1bb8c08c5c652d645bf24c0ad54c2d2ebcacf0b639165e9248328f58d5c38150227c2e6ac5315457dfaf5c1f3609f453b070aa3a9dd0a1172e7f8fc5bd2382c6c5f9a520fce924f5118a0643f37b0ff4cd79df27fe8afbdad9ba43a5e1a759d963578bf3f2241497436100780a2848eab38aa5fca8cecadc35140e6571d5fb0797a840f702f824eae1ec54f6c9944e9cba494f10e1a68e08b45a063200dabca293141ccbb4b8e5169b795ec0cf7430c590e2a8fefa42916f0bf6248edcd78e5df37b6c2eb16c4851602b60a728fd8e981928edd8e98ccc1b26242e31b81f167f65d42d0b99867b2f3bb8f00e3c900944f8c6197429ded5d0e4c3b71ee18172c480fb2100aa64d6bee46a3481646937075d9e5d13db450333e8176b1f211a5eda11fc72506544be0699ca3f0d94a8db81535608c0c8733e2ba9e2b7ec0fa22e4358f3a47c6304fd81db18773c339b2a88d1ae5e9d040a6e4a20fc26ea25d0cbb44f47c484056d58a15d3f8a96260c4b43bd4e58f9796fb8272a2cdc560389c8076190c5859ca6780b1744eb02da92399979245e8789cd44957e93ed952954715723d8c25390d3d9dc3b61681b0fcc2d91004e2b84bb3421d0b86b9a54dc72e974103878106aee99cca3d6e554ad2c41d41de4b6aff548b116e32135128cd8823d1d90d7dc94d095963d4b7d4f1a938ac86a7d93c9a103ea51474b1f10b70e2014f14810831818b4ec65611e288d24c28ea24f5f5f7e37e7b8578dab31d702c389291c944f383f5ba3e6fa195daf6d231de1c11a3560d30744650b610c914022491ba0593d919de11329d325eb05bd74a083a22ab4bbb54c7bdbad16a004176b89c04338d635a05cf2f26632f60a4eec7afce6296e190daf683bc88c48d48f315f3f105ed1b62213324cb224a7195e0cd50d4acf64f96c3c2cb0d2eb9220f4efbf75360ecfdbba3f48d6a8752534f3bc3833d84ec8d636cd3d62b2cbb5812f569681b32e5a6f39019425d19a8e7f34dc5cf6cfed1d16b42af8d7bd6fabcfa2b43fd59c0715ee5b525e115f5fcf5e9cfaa5951fbfbd612d04a6bd1bc502b52a596eb1cccac4faf91c6b846b6b241e16490858a0e8a78f27e145bca8678e7d7528096ebe89fa96c10d352dcb625c1180eb1fb8a2572ebeb39f30371506809ec1fbae0239ad11591b86bbbd22c9a74a0e10f7872e32766a2cec7398996f20a93e53490dc1baf3e99619f7f50deca6264290c5718f5ffaab3399fbc465d7b3f208bbc362f125c961f8a1cc7f27974dca19db434b72c9bf1bb3232a5e6f5eb366c08ab99c87bc8434b31a80b09b4d12c3725457461522d0f17ec3ad31b796cb69f5a4414e76f5f8007065e0fc3a7f97d888e787f06501a576d193d36567904830d68f69317f2904fc01abb7967bc24fbcb5b2ccddc335ea3c7d087d134486aaecd2a2c98b32957924eed46f80662b9f20619dc560125a002d2fc61e5630fc800691fc274db4ac363c64a3eaaf6ca9e5fdc87689858a238b77949a56a3f12dab2b1aa3a25bcaac2c7376b0b974eabdcfb707ea4930caffb6ffb4be7e48b987dd3b00fa5bf5155aa052a5c5f7447780528a1d29de9e579af66a710b2d4ee0ac3685a9295ba0bf8cf2d357a10d829850bb7b4aca79f36087330e43961e6f87a4ca4c106e7a81c4bdc2bb40b95ad6f2d64706582de4af68c5e9bac914f1a2a6a3574fea34a154478e7e6a1c20caec3ef1b82b9c7b7b735188fdaed05c4abbd1e5aaa334f83f16bc9050732d9ac8821f994d66b8d200bc0c25f870c92bf55d152e15477e85be11a723e87c99c7b3319478f49160d7292d63f57160897866ed3d1672519db5cd278429886dea64c3e7a1ff07b591b18fcd647c4e43727a4c5eb49e042d83d6a696b573b436ad465280030ef753effb2851fbad501cadd8c91ef0b3baaf5b5a75b0db97300c081a66ba22c3e0b0e7ab4dc6c920c815fa939ac0173a2ab5d9c93309c9bff3633de288c484172bbd1b7c720fc0a56ccb3e5ef2a788cf6ab7f60836ccfe8d675e732a3855a91d180674fd0161ec15a394ccbac7875a3855d6952abf6588964d7229729729688af5d9fc4369ceca2261e0ef5f94df545edb1c6e43a66ab181a90f2e672199bbcfff687ae1bf3710c0581ea4eb107a0336cb86c59d7f6aba6a61c52eae7da0d0dd48fc23e14d92d5da16bc8f1dfa1314dbbcebaec4687da1c50bc119fc879a0060a0bea6adcec2ef34f4858088ddf36c524e8691550a95a45cd84badd08b440e11bdd00224524b68ddd89358fa79ca447ae4673f00736d6ecacddb3f69ceb93600eacdbcba09d37c7081459b47b733e4a03af8fdd3c2a3b934cee3687c267e1f6f778f790d98cd8bfcad4a7e824e63d46e4077b8ce5c2571c17c4cfb1b93bbb1e5281e4e2358b915b03b9f2b628bb9ed44d0322d3933a0a20710e8002ed244d5121368338bfba8bb80dc18052956a2c19535f359c33dd4aa9bd011537323d2fd7f79821db78515eebe9d2d248332d7ea4a1794a92ceb215d9dace7acc1ba4e9da4fcd5eb8ab939156968c40c9cb7ecfdf7bb8f4ea151fbf917cc99a09c22a8abdd2a9d28a0767a1e433ae4e5b8c48cf49f07d8279ddae8e5b0f53d43da387e26c064e3b72df663efcb4e7fe0355c16d29acd1b157652934d4fad28691a792492bd3374dd7969bf3c0a7b790b3dcb156fa8a6088489075d97d6aec4aad7d69cdbc56370c66c73f25cf306c8b496558e4655f673e986418ae9590f37fa0a1deb28c06c4c024771649aac9cd41a5486762614860fa702076993ac7662e331d86dddaf1d40c1a1396e21675d19bcadeba3a83c71d9e042208b4b431f56e1e836f7f16ea884682d876a90ca41d1a0f1407b17b8f6e99fe6c92387169190230a5adf8491476bd3e11e40bc920b927740deea91acc58ecb854427ff12413b33588b4a60f1c5a99fc14a0bd837febcf7a470b70edcba2ec77c43c588cc2ba4cf7fd94f02cb70427a5ee4b7a68b59b2d5726a5a8a5212c8cf70d7a7ea84f4ae5fe1971d637faf39452af1d321d638eef12a3f4641e52f1985aacdb924d4f44c1b7d253e51e51811a8d20dc339de501bc889e4e3208e0843868dd55278ecf319855383b633d787b01e646f7c24019eed046601e5b1c40909ac39030a01cd3e69c91bf82680b4ed56e9dc07fd64040eea2215c1556acabb6e84ffb76f2cd4e15d76239ee1558636113ac078f0b9ec8d715abbe803d251eb0c7c1a0df4053d1848539bc260df3e6151114952487c3a26ba502a93ebb0cf9487c753bef1df89f90da24b0757f48038db998660179e9b5737a5131543f825eeffcb24f2e2f748d232cc75f222f82ff085a1dd59858405b0317c401e7d5eff349f19cf03902f73aa44f47049d0ff27c16278d435c5dc9d5c5d4b02b5ba388444bd071bc52d7ec63e0b54811d37d14a62e86e2178544add2452c9819e304c975f041f02771ec4bee7e3a3340d386d682849d73eab8ccb75c212873ea0fdb1bf0363cba313b2f383b36db611ed02f8eca5321d405f32f0cbb5e695b8789256c833542d0988a77d6871edc34f0e29b5da3d558873d5e370c356466a90ecec967d5f8a09dc974603813f94f10b1054aa8e7485fad3cf32e82ba51f939723d8e665d8f7b11fc20607575d85b9048b6488644987c0ba4ba7a2a54737eb1774405cf99313612eb6c1321ef5efdd345122b7c4b95fa1bbef26e6051d7fff926407b6bc5f0f5fe463f2e1c20d02bacc9eecab7ae35452b5902009a35dd40d4408697f66c85264119ad8d3022ae499dfc1b03a4ce827be29c052b94295fa27b7c114250c4134722619e78d2c24f9fbbf6c231cab9fc8e028bf2feac6064e572ee87c33b694be28a9946e1e6cf29feb057c07845a362e0c0bd235380279961d7626ffb378d6fbbd64f6a967a6e19382f998de263243a8d785c0396b18f5ebf928dc3c00806b4213601259562da09e27c57515aa8c28a7cb536b76874dbf86321583a7f7a8a6cac1aeaff13a331c120bdf35c00ee562b614fec315b227df27c7c9284f1d462cd7ce41aa048cdd754065147a726398bd702fe49f121d1e8c413cca2ccedfb9055f06016377ede9e6fb07ac51337eb10497e41527551b3bc36974670e2a9b99809c5341b9b4829c9c156eeeebe79556e5c8de6224e2b72e7a9204b615e58ce0716933a27f250bc1f69f619b34f7dd7ecadcbb44ab93406b56f63703b4b76a0d6afb13a79f63a176d4b5446799e250a7b2c1d34c4895b56a633ce4e845b87072fc7c63fea173fb76913919dfda8b46dfd20e23436ede7ef00ad652699ff48df41f717df15e304bcc32e48a6fef77b177c1fe60cd7d1f637859a9c4c0b59299354e5cebfbf5da52e44b700fbde73c27182b967517a6837d0c8ae85922b78488ee12ba50486ffe41b2ef34e028c5ef14fccde74f2de47a448b8656530877fccc25e42fe21cf6417747ea8c20edd40e27ddf261fc64a2de69f014509d75b5a24df9ad9e0753b65672cce98ec8a88d09a0832549a3680a46f044094bb7599e92ee8b0be1723de949a93ac65dea513c1de64705cb4d5ea06bcb788d69b48799f8ac9f503e9385f8d251b0943222bc6f057a68740d0bd52810a787a6fe1054fe37167ced1ec3133d9c1e3a663a9c5e4fa7756df887cb3799434e1dbd5a0e1e2f990ce2fa1a650c31a6d8f4e904e6f8b80047dcf5576a712a686748ef0cf1133345ce48caa898009d4745361b45cf1485ecf6975ce3aeb1c14930dc0801899b80e0d6cbd9fcbdc634fb36605b0ea0d0e8cc640a9529f4fb85d4e4f8cca7765c695acbaa75d1cbbd4a6ec4a4554a9f10011ef17d453e761302d199cfe791505321d40a87bedfbe9aeef6bada4851c0b489bda259002db1da54cd71af1c7171f8582c6efa9987636de3f00177b640dc6e104626444f9b4e58bff0b1eb323f1e11a69ef892ab534bf5e5e1941035eea6275069354ddb0ad744ba233abaea52ab5a968a97c3db9ca0288da001aa5d64a892c0fdf1dabc6897551688b7170fbcddfbbffcbc9b13646de493447ad129b86894f953a954066ba29153e0c768f5b0b7c669a0a84285d0951c05c69da6145008f87f1a297b8ad6d8ab6419bca2e0835a1e7683bf8ff7ab873382fbaf8788a65b53b83cf4e0c498fd347dbf5fdc2ebd6a932272414d025bc7b6d311a56018e14298ba325560e4650740dc5adcf5842bff42a34c3db2c7430ca5b7e60a2ce1fe005d3743d58a8e57b7291723129f3897099939949f961c820dc2ee07398c8201183f7a21f2bcfc8822790ff49c4f704d8c9a164ad1b682f30dc3992b1d49cb481c4abfa22210d8128bc9d8fe9bb7dd52ab8c1a105a05989e4dcb76fbf34024bda36dfae38e2cb5d0ac6282e968147b17375c4afa84656ea2ac10ee6dfabc23ea11be9fdaed263bec376bfceb9956a34af11e460cf84c88c89a0d5c3f52259405535a2452b6ed0186871bdb750e1518e2730f11bb52688df66f4090d71b28beb2d44d3552f184c0c9910dc239aba0040251c9d03054e1410e03354d2b2a64779b2898b2e1707a79168035ca38fccb58b0893d0e54b6c3aecaa51fcc48a8925d1dc5e296888b09e1ba69d549bc42dfc2b53b3981d1009587d8a2e8ab1b4a7049a4af6902fc99c2a030149ba0baa83f697c02284657740190aef6d5479a55150c4028f3e290d03fb800e070e728727a5b6c11b6460495734e64f3eadf7e0ea3f82319dc43d1fd6814cbbe0c36c3c9e144d5e5a0715c2525993669e3ed215ce7f949d926976659d0b72cc487ff3facd60ea3367b9025e18f6cdbddfd1b3c6a5d48b9c5f9638e568a2aba397b7859337aee119fcd97e87d5bd1b500aebffbedf74a57830e86940ec5e5dbf2683846a9f9c7aa5677d0a30e50b867bc4c4e2e66bd2a1405710bd2e21694f48c4f5d45e4d65f248d2e665b1cef1b99e8879538dae4d4cb31432971b621373a9e33d325e5d97c02b28a6a224bafeeed94fe95cb9335c92d97195bcb3d7d9cb98c0b4887b61022b02d0a6f0a2180943626a2b664a55401bedc8aab3a85541a345507af6599941f1f8f7269baaa17fd0e552fc8aaeba1e7766b55264a028b0c318ca18f1aa056bc4d8010e810669a0f7323d45b70db8af150ce0149dc3a90088197c367ff70771ab84395f4f5c57afc3e55308e652bf917f3d3dd6f8eb9286d15daa139b80093df7a053d3ca90c82a0628b1c9a44b95d6ed31a878ea504afb80dda2011aa3994f44b6d0e50184297ebb6c89093a3db332dd0db6361dcb3eea9a055c8910d070e1515b8902609e1cace24d7c0b856d0273d240697cf38de0012dcc432d6a7d87bff29748c8e970376a1976b1e877a490d000d81afe8945a0eee95256325dc2cbdb1221f8795c6acc5500187d9bfaaba1230b4cbc16979bb6bef6717d0332a03ec6c5c1dc8239c5f992f1351f3544c4e1b4202c31bb6482bfcf3635e8847cd1bdac27ce6df97e6f2a7cb77f2cd5638dea4d487bd52b48e99bf462efcc7c94bd38207dde14a57a9e8bc64078f223fda106bc80e98cf7cef745890968c7f9cbc29ec979a5a3b7b6fba39df5728e5d57ec90f8f79247626be34ac94081e872071dda74accf29efbda39c109171ffdbe7d46bd89cc4a57f784276e65261cf490c259902425bb747c2a616be906ee7827104a8a30710d803d485ef4bb0b51c139f01a5b45ff47b0058eb2efede27d5ff8f02b43b43805bb36deb17085ff8781a4a5470b72e08c830c83eca17680426018e7823fa876738794e80cb008c51f0bf9d6b56e89f790ad00b267bf3a4957febf555902c5e070adb3585574b5e58f92df163d41a437f4e03231901272404ab426583b037f1a4a33e01adbcea60299a6a0f9b5cb585a5aada97b9753ad1689b5302915c62be7c6cfd04a71047d5aefa2cfb243ee438b3569e83d41b7a11bddfb6f2656eb5e9477da83ec91e3feb18a6fd55b34e437f08f16438e7e8d59321de60be5e7b3c9883090af138887740ab23aa8c7aba188b8d0375707eff7276845d7e5462c75ed7ed750de5a5c928ab1d4923137593dd0fe9441b86694b88963a7bfabee5c9a967407d366c90d016b206dff897c6a59799a8ed1ed6fe7b53eff39007d9c4afd40b12a7637c7f6307e208f1a9c50f722d6739b49e510261b75fe4096beeafceaea3c28380bb513f6a1e0d4ff260e18b2a6fb767612521ec6739a1309c721219eefb190e04c35fa9ae9202670439b34cd5f45efb58eb0fb0c3eb0fc474040ea2ff2a0af138ea00a1a36074667324a712f8044b0a13e552d795a19bd0c8a4bd4b9b8ec2b7cf532e18c6e7e04b76b0e65241802d57dfafe053aafaa5213b38b74231eb8d549827c5e640abd9e9ae9009adc911749cfbbc34ba8b4545b01a107e14cf07029d3e05d02bb66a39602c1af0c0ecd468bf8e7bdd01d086aaf2e64844c857840ed87db1e0e289f7338fbc60fd3f26e30d15b6778a3d2c7b736c052010bdb3cbfeeb67bb9c3afbd4a77b6f58655a30b26d156a476c584ae95e706eaa5549a42e32b5201753e4153b5dba2404ca3f85674fd4b0f9f1959391179809f5286ed55b0e81f15a4f52498af82a08b23016a6c4c87031c3b2d54a9b811ff2e419f0840807996e07fc761206dd666e4bc932127a3922c039b79aa0f16d8a1b77a19832cc74cefc178ae3d160cee95929aff4f609199e34fca6994a3520872ae9e7e0d0c5155922e18946f2a77b6b7746f3bcd82e4daaf1a7ecd9ff19289c6f35a9a78622c26eee7fd041f61b93e74a5fbe23c80b0465df10f1728f197c1ac28d4acbe935e96582be0ded31a31c073b87e9decf67dcbd051148caa9584791599626487077caf999c98100ab453fde9fb0fb2ce6309aff9365b362b56abf804c482e9ab97ff6780aebe475fdbe588014a468005270eb76d0de966b91619ec8b75426222204f3947158f86a170da3209837b6f8021f33bab09dba0ebf43df1fc089d6e21590436f11391f320df5425449e054dd48df07ecc20fe4528835319cd16dcbbd84a22a1d91201401104f9a570ad02e2c394116d62b0b47842464f7c6d30bf954e36e036183ef1370831ba9b1c3d1b5131a46d95451ad65db9766ad0d1bf91673980b51667f4e748aa3378ae720844a74967e97631191a4427719e31faa618f34a782016f0fd9b5e2877c9bd3d94e8c589eda7cae81eb8101df2c2852409400f2571f39498cb160ac525e177e2722c322045b55b2fa769f66f25b8b4f50417342b951d7a8dbf4553fb5c7e6454f6e1909db1dd558d0084320068602788ef9978e991bc81618ce227bf85f7859783241ef37faa09af72bb4fcf731a3ac5256229e4a96f57fbd6ae60152fc807d6cc36e080c07b08e70d7d7b1dd0dbe8735054ff099fd165fdcec6d4655e7846bb561229f6b98122c0fc78708384469b0457c0be38991da8e957c4592236791583af29f2c29d48b2bad77c9680f145928a3de50f66a574bbd706da57cfc82354ec9a6fb6f4e1dd481bd39bd62b821a8c549b4dfc419d38f136a93a7ceebd63adf23ae4fdd4561a094d5b5e6db63fc38310e517df040669aa27095758274799a6aef9a81099aeb3595e9b18ca7aa2a22975d735b6c1fc75914d073f9bea7a23ce5eb23cf702eed9898706a9e87d022ee73c144e29beb5dec6d264b368623a91598a916e8e0a8a209a7469678eaa2c93490c8baad47addbb20860d722d057d400977ffb99472c88f91d332ee08a2aa61dd4cbdc57815bf2a13ae1f8e91b871de0ac64748f29bc26c345298f145095c98458b76523e3e9ae045ec7b0f00efd97198e043e34f04ff7a54c0aff15c215b5954cb564eb2edc7340b187ca95df28fccf8a874db800d2442c2728d2090e7d628fe2925e95962e686ba63429e0092cdf52b76b2517e686aedb3f5aaeb3fba711fd17d948402f5e7c80675b90e78a3afba800e94ae345d057409d7d46f0eb7f13d7a9dc33e0c3f476fac858c9c15c6175588740e404bfef38dcb45fdcdaf6a40ad0e77b1c2039a361895194e103d11f1593d97d5bd660d90ba53d48a2be632a440823b7dd916022702fef32af42554ac840eb6a9abd33adac88fd307216056e18e65eda13bd4e3c0538e9b3fe53b0059d8729093cae228afb715023448e889aaea4f9b99eb491622b55597ba0c37b92e55ef7a52db3f831268853f201a5b03c5af4fa80cf151e8c00398b08960805dd57b8d12ce194d3985f97620240c78ab02d4a4e78fe6f0d76794b2a6f3d7b40df5a5cb4d335bf43d318797e4e86c6c7c9c45c95ad22b4d59055e29e8be2a594d99851fdb83d51c0cdf3ac9ae416e1d3428393a62343a2bdd825213775cf51a21de0906dbee4a95b021914858e6ccb7cd6ade4381dfea7b43d7a2bfbc1e6ec8fd7067b60f75561edc41c271bde9abd7344da4d5f0e0204b93e3cc2054995e61678d5e23330a6f3882bf28a4a958177bde8986065a34fe773fa16bad28406501e5e117f43f18e5a3ad7b183c5f950ff9940dcfbc50589d98523677a1a76cff3555848809ecd98a15bf80429ab738c2c7d952680ff5d41e5b564d637fa9ff13c434e2befd98fbb8edb648a6c99004529426440e5713865002141e980589673747e9f986f191a73ab5e327dd14f8a8072198a717216daf19d24c947058afe2efeb4fabf01995e2e378b95c3c89f5693f789bcffa21e543a84eaf5affb55bb75addabcd08b5a0217beefd0f87145c5f85a1e6e998ae98234bf37637a116e04b153337aa212f06dd1501c1969709954a8e9820e82367d76fa9586662fcf1c2e13736d457e22a6e12fd83e9346671dea72acb4cdb9fb16d1170f10e679a1fca8978e7c40b7ad81b4b03e1b21e06b55402766182d1a45fb4523728360ab735f6033038086456ae793b9dcbc236c86aa8be4b9fb3e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b73e62f8a278166caaba792afafed211"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
